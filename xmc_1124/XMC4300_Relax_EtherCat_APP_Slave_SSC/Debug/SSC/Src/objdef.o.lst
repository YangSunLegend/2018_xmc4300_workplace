   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "objdef.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .comm bSyncSetByUser,1,1
  20              	 .comm sCycleDiag,2,4
  21              	 .comm sSyncManOutPar,68,4
  22              	 .comm sSyncManInPar,68,4
  23              	 .global sErrorSettings
  24              	 .section .data.sErrorSettings,"aw",%progbits
  25              	 .align 2
  28              	sErrorSettings:
  29 0000 0200     	 .short 2
  30 0002 0000     	 .space 2
  31 0004 01000000 	 .word 1
  32 0008 0400     	 .short 4
  33 000a 0000     	 .space 2
  34              	 .global aSubindexDesc
  35              	 .section .data.aSubindexDesc,"aw",%progbits
  36              	 .align 2
  39              	aSubindexDesc:
  40 0000 53756249 	 .ascii "SubIndex 000\000"
  40      6E646578 
  40      20303030 
  40      00
  41              	 .global cBitMask
  42 000d 000000   	 .section .rodata.cBitMask,"a",%progbits
  43              	 .align 2
  46              	cBitMask:
  47 0000 0000     	 .short 0
  48 0002 0100     	 .short 1
  49 0004 0300     	 .short 3
  50 0006 0700     	 .short 7
  51 0008 0F00     	 .short 15
  52 000a 1F00     	 .short 31
  53 000c 3F00     	 .short 63
  54 000e 7F00     	 .short 127
  55 0010 FF00     	 .short 255
  56 0012 FF01     	 .short 511
  57 0014 FF03     	 .short 1023
  58 0016 FF07     	 .short 2047
  59 0018 FF0F     	 .short 4095
  60 001a FF1F     	 .short 8191
  61 001c FF3F     	 .short 16383
  62 001e FF7F     	 .short 32767
  63              	 .section .text.OBJ_GetObjectHandle,"ax",%progbits
  64              	 .align 2
  65              	 .global OBJ_GetObjectHandle
  66              	 .thumb
  67              	 .thumb_func
  69              	OBJ_GetObjectHandle:
  70              	.LFB172:
  71              	 .file 1 "../SSC/Src/objdef.c"
   1:../SSC/Src/objdef.c **** /**
   2:../SSC/Src/objdef.c **** \addtogroup CoE CAN Application Profile over EtherCAT
   3:../SSC/Src/objdef.c **** @{
   4:../SSC/Src/objdef.c **** */
   5:../SSC/Src/objdef.c **** 
   6:../SSC/Src/objdef.c **** /**
   7:../SSC/Src/objdef.c **** \file objdef.c
   8:../SSC/Src/objdef.c **** \author EthercatSSC@beckhoff.com
   9:../SSC/Src/objdef.c **** \brief Implementation
  10:../SSC/Src/objdef.c **** This file contains the object dictionary access functions
  11:../SSC/Src/objdef.c **** 
  12:../SSC/Src/objdef.c **** \version 5.11
  13:../SSC/Src/objdef.c **** 
  14:../SSC/Src/objdef.c **** <br>Changes to version V5.10.1:<br>
  15:../SSC/Src/objdef.c **** V5.11 DIAG4: change parameter handling in DIAG_CreateNewMessage()<br>
  16:../SSC/Src/objdef.c **** V5.11 ECAT: <br>
  17:../SSC/Src/objdef.c **** V5.11 ECAT10: change PROTO handling to prevent compiler errors<br>
  18:../SSC/Src/objdef.c **** V5.11 ESM7: "add Sync define for 0x22 (""SYNCTYPE_SM2_SYNCHRON""), support value 0x22 for 0x1C33.1 
  19:../SSC/Src/objdef.c **** V5.11 OBJ1: OBJ_GetEntryOffset: return offset 0 for si0 (always offset 16 was returned before)<br>
  20:../SSC/Src/objdef.c **** V5.11 SDO1: "Obj_Read/Obj_Write: Check if entries > 8bit has even word offset (otherwise ""unsuppor
  21:../SSC/Src/objdef.c **** V5.11 SDO2: Obj_Read/Obj_Write: Handle arrays (string, array of byte, ...) with an odd word length 
  22:../SSC/Src/objdef.c **** V5.11 SDO3: handle not word aligned enums<br>
  23:../SSC/Src/objdef.c **** V5.11 SDO5: add missing swapping on SI0 write access<br>
  24:../SSC/Src/objdef.c **** V5.11 SDO6: OBJ_GetDesc ensure that the default string is used if no string was found<br>
  25:../SSC/Src/objdef.c **** V5.11 SDO7: add missing value swapping if memory values are bitwise modified on object read/write a
  26:../SSC/Src/objdef.c **** V5.11 SDO9: "handle SDO access for entries which are not accessible (in case of SDO complete access
  27:../SSC/Src/objdef.c **** V5.11 TEST2: add test 0x300C object (entry bitlength > 65535)<br>
  28:../SSC/Src/objdef.c **** V5.11 TEST8: create diag message on SDO write access to 0x3002<br>
  29:../SSC/Src/objdef.c **** <br>Changes to version V5.01:<br>
  30:../SSC/Src/objdef.c **** V5.10 COE2: Change return value of Get ObjectSize to UINT32<br>
  31:../SSC/Src/objdef.c ****             Change object size to UINT32<br>
  32:../SSC/Src/objdef.c **** V5.10 ECAT11: Add define "USE_SINGLE_PDO_MAPPING_ENTRY_DESCR" (Only one entry description is requir
  33:../SSC/Src/objdef.c **** V5.10 ECAT13: Update Synchronisation handling (FreeRun,SM Sync, Sync0, Sync1)<br>
  34:../SSC/Src/objdef.c ****               Compare DC UINT configuration (by ESC Config data) vs. DC activation register setting
  35:../SSC/Src/objdef.c ****               Update 0x1C3x entries<br>
  36:../SSC/Src/objdef.c **** V5.10 ECAT3: Add new datatype handling (BITARRxx)<br>
  37:../SSC/Src/objdef.c ****              Use read/write marco to access STRING entries<br>
  38:../SSC/Src/objdef.c **** V5.10 SDO1: Handle access to enums on odd memory addresses (only for MBX_16BIT_ACCESS)<br>
  39:../SSC/Src/objdef.c **** V5.10 SDO2: Check for termination char in every substring<br>
  40:../SSC/Src/objdef.c **** V5.10 SDO5: Check also for PDO mapping object if the subindex 0 was set to 0 before the entries wil
  41:../SSC/Src/objdef.c **** V5.10 SDO9: SDO complete write access update buffer offset calculation in case of SI0 is readonly<b
  42:../SSC/Src/objdef.c **** V5.10 TEST2: Add 0x3004.14 (Access to this entry will always rejected with the code "cannot be acce
  43:../SSC/Src/objdef.c **** V5.10 TEST4: Add CoE test (0x2020.5) to return always max object data on complete access (not limit
  44:../SSC/Src/objdef.c **** <br>Changes to version V5.0:<br>
  45:../SSC/Src/objdef.c **** V5.01 COE2: Calculate the bit offset also for SI0 in case if an SDO download access.<br>
  46:../SSC/Src/objdef.c **** V5.01 SDO1: Update alignment entry handling.<br>
  47:../SSC/Src/objdef.c **** V5.01 SDO5: Update offset calculation in case of an not accessible entry<br>
  48:../SSC/Src/objdef.c **** V5.01 SDO7: Update object length calculation in case of an BitArray<br>
  49:../SSC/Src/objdef.c **** V5.01 TEST5: Add slave configuration object handling (0x8000, if test application is active)<br>
  50:../SSC/Src/objdef.c **** V5.01 TEST6: Add test to create dummy object dictionary.<br>
  51:../SSC/Src/objdef.c **** <br>Changes to version V4.40:<br>
  52:../SSC/Src/objdef.c **** V5.0 TEST1: Add test application.<br>
  53:../SSC/Src/objdef.c **** V5.0 COE3: Update OCTED_STRING and VISIBLE_STRING read/write.<br>
  54:../SSC/Src/objdef.c **** V5.0 COE5: Add BigEndian support for enum SDO read, handle complete access also for objects with al
  55:../SSC/Src/objdef.c **** V5.0 COE7: Support SDO Info entry name handling for 16Bit access<br>
  56:../SSC/Src/objdef.c **** V5.0 DIAG2: SDO Info request for diagnosis messages 0x10F3 SI5 or greater return always description
  57:../SSC/Src/objdef.c **** V5.0 COE2: Add plausibility check for PDO assign objects.<br>
  58:../SSC/Src/objdef.c **** V5.0 OBJ2: Support DWORD/WORD aligned object structures.<br>
  59:../SSC/Src/objdef.c **** V5.0 SDO7: Update SDO read/write for object(entries) less or equal 8Bit.<br>
  60:../SSC/Src/objdef.c **** <br>Changes to version V4.30:<br>
  61:../SSC/Src/objdef.c **** V4.40 DIAG1: Add diagnosis access functions<br>
  62:../SSC/Src/objdef.c **** V4.40 OBJ2: change counter variable to prevent deadlock caused by overrun (required if subindex0 is
  63:../SSC/Src/objdef.c **** V4.40 COE2: Prevent accessing empty object dictionary entry<br>
  64:../SSC/Src/objdef.c **** V4.40 COE3: Read whole object dictionary<br>
  65:../SSC/Src/objdef.c **** V4.40 COE1: Prototype of OBJ_GetObjectList() changed, set abort code if object dictionary is empty<
  66:../SSC/Src/objdef.c **** V4.30 OBJ 3: Object dictionary list handling<br>
  67:../SSC/Src/objdef.c **** V4.30 OBJ 2: fix SDO complete access bug<br>
  68:../SSC/Src/objdef.c **** V4.11 OBJ 1-3: OBJ_GetDesc() Now, subindex 0 instead of 0xFF is used to return the description of t
  69:../SSC/Src/objdef.c **** Subindex 0xFF could be used like a normal subindex.<br>
  70:../SSC/Src/objdef.c **** <br>Changes to version V4.08:<br>
  71:../SSC/Src/objdef.c **** V4.10 OBJ 1: calculate size of PdoObjectEntry Index 1 and not Index 0<br>
  72:../SSC/Src/objdef.c **** V4.10 OBJ 2: the pointer of the object dictionary will be get by a function (COE_GetObjectDictionar
  73:../SSC/Src/objdef.c **** <br>Changes to version V4.07:<br>
  74:../SSC/Src/objdef.c **** V4.08 OBJ 1: if subindex 0 is writable, the maximum subindex should be checked in an object specifi
  75:../SSC/Src/objdef.c ****              because for the PDO mapping and PDO assign the object shall only be written if subinde
  76:../SSC/Src/objdef.c **** <br>Changes to version V4.04:<br>
  77:../SSC/Src/objdef.c **** V4.04 OBJ 1: The loop in OBJ_GetObjectList was one subindex too low<br>
  78:../SSC/Src/objdef.c **** <br>Changes to version V4.03:<br>
  79:../SSC/Src/objdef.c **** V4.04 SDO 1: The SDO interface was changed in that way that a SDO response<br>
  80:../SSC/Src/objdef.c ****              could be sent by the application to a later time. In that case<br>
  81:../SSC/Src/objdef.c ****                  the functions OBJ_Read and OBJ_Write shall return the value<br>
  82:../SSC/Src/objdef.c ****                  ABORTIDX_WORKING. To send the SDO response the new function SDOS_SdoRes<br>
  83:../SSC/Src/objdef.c ****                  has to be called by the application. While waiting for the call<br>
  84:../SSC/Src/objdef.c ****                  of SDOS_SdoRes the SDO interface will answer to another SDO request<br>
  85:../SSC/Src/objdef.c ****                  with the error MBXERR_SERVICEINWORK in the mailbox protocol<br>
  86:../SSC/Src/objdef.c **** V4.04 OBJ 1: The loop in OBJ_GetNoOfObjects was one subindex too low<br>
  87:../SSC/Src/objdef.c **** <br>Changes to version V4.02:<br>
  88:../SSC/Src/objdef.c **** V4.03 OBJ 1: The object list was not returned correctly for the list types 2-5<br>
  89:../SSC/Src/objdef.c **** <br>Changes to version V3.20:<br>
  90:../SSC/Src/objdef.c **** V4.00 OBJ 1: The OBJ functions are modified for a more flexible definition of<br>
  91:../SSC/Src/objdef.c ****              the object dictionary and to support bit types too<br>
  92:../SSC/Src/objdef.c **** V4.00 SDO 2: The object lists will be generated in the functions OBJ_GetNoOfObjects<br>
  93:../SSC/Src/objdef.c ****              and OBJ_GetObjectList in objdef.c to decouple the SDO services from<br>
  94:../SSC/Src/objdef.c ****              the implementation of the object dictionary<br>
  95:../SSC/Src/objdef.c **** V4.00 COEAPPL 2: The handling of backup parameters was included according to<br>
  96:../SSC/Src/objdef.c ****                  the EtherCAT Guidelines and Protocol Enhancements Specification
  97:../SSC/Src/objdef.c **** 
  98:../SSC/Src/objdef.c **** */
  99:../SSC/Src/objdef.c **** 
 100:../SSC/Src/objdef.c **** 
 101:../SSC/Src/objdef.c **** #define    OBJDEF        0x4000
 102:../SSC/Src/objdef.c **** #define    OBJDEFMAX    0x0A
 103:../SSC/Src/objdef.c **** 
 104:../SSC/Src/objdef.c **** /*---------------------------------------------------------------------------------------
 105:../SSC/Src/objdef.c **** ------
 106:../SSC/Src/objdef.c **** ------    Includes
 107:../SSC/Src/objdef.c **** ------
 108:../SSC/Src/objdef.c **** ---------------------------------------------------------------------------------------*/
 109:../SSC/Src/objdef.c **** 
 110:../SSC/Src/objdef.c **** #include "ecat_def.h"
 111:../SSC/Src/objdef.c **** 
 112:../SSC/Src/objdef.c **** 
 113:../SSC/Src/objdef.c **** #include "ecatslv.h"
 114:../SSC/Src/objdef.c **** #include "coeappl.h"
 115:../SSC/Src/objdef.c **** 
 116:../SSC/Src/objdef.c **** #define  _OBJDEF_    1
 117:../SSC/Src/objdef.c **** #include "objdef.h"
 118:../SSC/Src/objdef.c **** #undef    _OBJDEF_
 119:../SSC/Src/objdef.c **** /* ECATCHANGE_START(V5.11) ECAT10*/
 120:../SSC/Src/objdef.c **** /*remove definition of _OBJDEF_ (#ifdef is used in objdef.h)*/
 121:../SSC/Src/objdef.c **** /* ECATCHANGE_END(V5.11) ECAT10*/
 122:../SSC/Src/objdef.c **** 
 123:../SSC/Src/objdef.c **** 
 124:../SSC/Src/objdef.c **** 
 125:../SSC/Src/objdef.c **** 
 126:../SSC/Src/objdef.c **** extern OBJCONST TOBJECT OBJMEM *pSdoInfoObjEntry;
 127:../SSC/Src/objdef.c **** extern OBJCONST TSDOINFOENTRYDESC OBJMEM * OBJ_GetEntryDesc(OBJCONST TOBJECT OBJMEM * pObjEntry, UI
 128:../SSC/Src/objdef.c **** 
 129:../SSC/Src/objdef.c **** //---------------------------------------------------------------------------------------
 130:../SSC/Src/objdef.c **** 
 131:../SSC/Src/objdef.c **** /*---------------------------------------------------------------------------------------
 132:../SSC/Src/objdef.c **** ------
 133:../SSC/Src/objdef.c **** ------    Internal types and defines
 134:../SSC/Src/objdef.c **** ------
 135:../SSC/Src/objdef.c **** ---------------------------------------------------------------------------------------*/
 136:../SSC/Src/objdef.c **** 
 137:../SSC/Src/objdef.c **** /*---------------------------------------------------------------------------------------
 138:../SSC/Src/objdef.c **** ------
 139:../SSC/Src/objdef.c **** ------    module internal function declarations
 140:../SSC/Src/objdef.c **** ------
 141:../SSC/Src/objdef.c **** ---------------------------------------------------------------------------------------*/
 142:../SSC/Src/objdef.c **** 
 143:../SSC/Src/objdef.c **** /*---------------------------------------------------------------------------------------
 144:../SSC/Src/objdef.c **** ------
 145:../SSC/Src/objdef.c **** ------    Module internal variable definitions
 146:../SSC/Src/objdef.c **** ------
 147:../SSC/Src/objdef.c **** ---------------------------------------------------------------------------------------*/
 148:../SSC/Src/objdef.c **** const UINT16 cBitMask[16] = {0x0000,0x0001,0x0003,0x0007,0x000F,0x001F,0x003F,0x007F,0x00FF,0x01FF,
 149:../SSC/Src/objdef.c **** /*---------------------------------------------------------------------------------------
 150:../SSC/Src/objdef.c **** ------
 151:../SSC/Src/objdef.c **** ------    Functions
 152:../SSC/Src/objdef.c **** ------
 153:../SSC/Src/objdef.c **** ---------------------------------------------------------------------------------------*/
 154:../SSC/Src/objdef.c **** 
 155:../SSC/Src/objdef.c **** 
 156:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 157:../SSC/Src/objdef.c **** /**
 158:../SSC/Src/objdef.c ****  \param     index     Indicates the index of the dictionary object.
 159:../SSC/Src/objdef.c **** 
 160:../SSC/Src/objdef.c ****  \return    A handle to an object of the requested index or NULL if not found.
 161:../SSC/Src/objdef.c **** 
 162:../SSC/Src/objdef.c ****  \brief    The function looks in all objects of the dictionary after the indicated index
 163:../SSC/Src/objdef.c ****              and returns a handle if found.
 164:../SSC/Src/objdef.c **** 
 165:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 166:../SSC/Src/objdef.c **** 
 167:../SSC/Src/objdef.c **** OBJCONST TOBJECT OBJMEM *  OBJ_GetObjectHandle( UINT16 index )
 168:../SSC/Src/objdef.c **** {
  72              	 .loc 1 168 0
  73              	 .cfi_startproc
  74              	 
  75              	 
  76 0000 80B5     	 push {r7,lr}
  77              	.LCFI0:
  78              	 .cfi_def_cfa_offset 8
  79              	 .cfi_offset 7,-8
  80              	 .cfi_offset 14,-4
  81 0002 84B0     	 sub sp,sp,#16
  82              	.LCFI1:
  83              	 .cfi_def_cfa_offset 24
  84 0004 00AF     	 add r7,sp,#0
  85              	.LCFI2:
  86              	 .cfi_def_cfa_register 7
  87 0006 0346     	 mov r3,r0
  88 0008 FB80     	 strh r3,[r7,#6]
 169:../SSC/Src/objdef.c ****     OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
  89              	 .loc 1 169 0
  90 000a FFF7FEFF 	 bl COE_GetObjectDictionary
  91 000e F860     	 str r0,[r7,#12]
 170:../SSC/Src/objdef.c **** 
 171:../SSC/Src/objdef.c ****     while (pObjEntry!= NULL)
  92              	 .loc 1 171 0
  93 0010 09E0     	 b .L2
  94              	.L5:
 172:../SSC/Src/objdef.c ****     {
 173:../SSC/Src/objdef.c ****         if (pObjEntry->Index == index)
  95              	 .loc 1 173 0
  96 0012 FB68     	 ldr r3,[r7,#12]
  97 0014 1B89     	 ldrh r3,[r3,#8]
  98 0016 FA88     	 ldrh r2,[r7,#6]
  99 0018 9A42     	 cmp r2,r3
 100 001a 01D1     	 bne .L3
 174:../SSC/Src/objdef.c ****             return pObjEntry;
 101              	 .loc 1 174 0
 102 001c FB68     	 ldr r3,[r7,#12]
 103 001e 06E0     	 b .L4
 104              	.L3:
 175:../SSC/Src/objdef.c ****         pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
 105              	 .loc 1 175 0
 106 0020 FB68     	 ldr r3,[r7,#12]
 107 0022 5B68     	 ldr r3,[r3,#4]
 108 0024 FB60     	 str r3,[r7,#12]
 109              	.L2:
 171:../SSC/Src/objdef.c ****     {
 110              	 .loc 1 171 0
 111 0026 FB68     	 ldr r3,[r7,#12]
 112 0028 002B     	 cmp r3,#0
 113 002a F2D1     	 bne .L5
 176:../SSC/Src/objdef.c ****     }
 177:../SSC/Src/objdef.c ****     return 0;
 114              	 .loc 1 177 0
 115 002c 0023     	 movs r3,#0
 116              	.L4:
 178:../SSC/Src/objdef.c **** }
 117              	 .loc 1 178 0
 118 002e 1846     	 mov r0,r3
 119 0030 1037     	 adds r7,r7,#16
 120              	.LCFI3:
 121              	 .cfi_def_cfa_offset 8
 122 0032 BD46     	 mov sp,r7
 123              	.LCFI4:
 124              	 .cfi_def_cfa_register 13
 125              	 
 126 0034 80BD     	 pop {r7,pc}
 127              	 .cfi_endproc
 128              	.LFE172:
 130 0036 00BF     	 .section .text.OBJ_GetObjectLength,"ax",%progbits
 131              	 .align 2
 132              	 .global OBJ_GetObjectLength
 133              	 .thumb
 134              	 .thumb_func
 136              	OBJ_GetObjectLength:
 137              	.LFB173:
 179:../SSC/Src/objdef.c **** 
 180:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 181:../SSC/Src/objdef.c **** /**
 182:../SSC/Src/objdef.c ****  \param     index           Index of the requested object.
 183:../SSC/Src/objdef.c ****  \param     subindex        Subindex of the requested object.
 184:../SSC/Src/objdef.c ****  \param     pObjEntry       Handle to the dictionary object returned by
 185:../SSC/Src/objdef.c ****                             OBJ_GetObjectHandle which was called before
 186:../SSC/Src/objdef.c ****  \param     bCompleteAccess Indicates if a complete read of all subindices of the
 187:../SSC/Src/objdef.c ****                             object shall be done or not
 188:../SSC/Src/objdef.c **** 
 189:../SSC/Src/objdef.c ****  \return    The size of the object entry in bytes (!).
 190:../SSC/Src/objdef.c **** 
 191:../SSC/Src/objdef.c ****  \brief     This function returns the size of the requested entry. If bCompleteaccess is set the si
 192:../SSC/Src/objdef.c **** 
 193:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 194:../SSC/Src/objdef.c **** UINT32 OBJ_GetObjectLength( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT
 195:../SSC/Src/objdef.c **** {
 138              	 .loc 1 195 0
 139              	 .cfi_startproc
 140              	 
 141              	 
 142              	 
 143 0000 80B4     	 push {r7}
 144              	.LCFI5:
 145              	 .cfi_def_cfa_offset 4
 146              	 .cfi_offset 7,-4
 147 0002 85B0     	 sub sp,sp,#20
 148              	.LCFI6:
 149              	 .cfi_def_cfa_offset 24
 150 0004 00AF     	 add r7,sp,#0
 151              	.LCFI7:
 152              	 .cfi_def_cfa_register 7
 153 0006 3A60     	 str r2,[r7]
 154 0008 1A46     	 mov r2,r3
 155 000a 0346     	 mov r3,r0
 156 000c FB80     	 strh r3,[r7,#6]
 157 000e 0B46     	 mov r3,r1
 158 0010 7B71     	 strb r3,[r7,#5]
 159 0012 1346     	 mov r3,r2
 160 0014 3B71     	 strb r3,[r7,#4]
 196:../SSC/Src/objdef.c ****     /* get the information of ObjCode and MaxSubindex in local variables to support different types
 197:../SSC/Src/objdef.c ****     UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 161              	 .loc 1 197 0
 162 0016 3B68     	 ldr r3,[r7]
 163 0018 9B89     	 ldrh r3,[r3,#12]
 164 001a 03F47063 	 and r3,r3,#3840
 165 001e 1B12     	 asrs r3,r3,#8
 166 0020 BB72     	 strb r3,[r7,#10]
 198:../SSC/Src/objdef.c ****     UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUB
 167              	 .loc 1 198 0
 168 0022 3B68     	 ldr r3,[r7]
 169 0024 9B89     	 ldrh r3,[r3,#12]
 170 0026 7B72     	 strb r3,[r7,#9]
 199:../SSC/Src/objdef.c ****     UINT32 size = 0;
 171              	 .loc 1 199 0
 172 0028 0023     	 movs r3,#0
 173 002a FB60     	 str r3,[r7,#12]
 200:../SSC/Src/objdef.c **** 
 201:../SSC/Src/objdef.c ****     if ( bCompleteAccess )
 174              	 .loc 1 201 0
 175 002c 3B79     	 ldrb r3,[r7,#4]
 176 002e 002B     	 cmp r3,#0
 177 0030 43D0     	 beq .L7
 202:../SSC/Src/objdef.c ****     {
 203:../SSC/Src/objdef.c ****         if ( objCode == OBJCODE_VAR )
 178              	 .loc 1 203 0
 179 0032 BB7A     	 ldrb r3,[r7,#10]
 180 0034 072B     	 cmp r3,#7
 181 0036 01D1     	 bne .L8
 204:../SSC/Src/objdef.c ****             return 0;
 182              	 .loc 1 204 0
 183 0038 0023     	 movs r3,#0
 184 003a 61E0     	 b .L9
 185              	.L8:
 205:../SSC/Src/objdef.c ****         else if ((objCode == OBJCODE_ARR)
 186              	 .loc 1 205 0
 187 003c BB7A     	 ldrb r3,[r7,#10]
 188 003e 082B     	 cmp r3,#8
 189 0040 18D1     	 bne .L10
 206:../SSC/Src/objdef.c ****             )
 207:../SSC/Src/objdef.c ****         {
 208:../SSC/Src/objdef.c **** 
 209:../SSC/Src/objdef.c ****             /* we have to get the maxSubindex from the actual value of subindex 0,
 210:../SSC/Src/objdef.c ****                 which is stored as UINT16 at the beginning of the object's variable */
 211:../SSC/Src/objdef.c ****             maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
 190              	 .loc 1 211 0
 191 0042 3B68     	 ldr r3,[r7]
 192 0044 9B69     	 ldr r3,[r3,#24]
 193 0046 1B88     	 ldrh r3,[r3]
 194 0048 7B72     	 strb r3,[r7,#9]
 212:../SSC/Src/objdef.c **** 
 213:../SSC/Src/objdef.c **** 
 214:../SSC/Src/objdef.c ****             size = pObjEntry->pEntryDesc[1].BitLength *maxSubindex;
 195              	 .loc 1 214 0
 196 004a 3B68     	 ldr r3,[r7]
 197 004c 1B69     	 ldr r3,[r3,#16]
 198 004e 0633     	 adds r3,r3,#6
 199 0050 5B88     	 ldrh r3,[r3,#2]
 200 0052 1A46     	 mov r2,r3
 201 0054 7B7A     	 ldrb r3,[r7,#9]
 202 0056 03FB02F3 	 mul r3,r3,r2
 203 005a FB60     	 str r3,[r7,#12]
 215:../SSC/Src/objdef.c **** 
 216:../SSC/Src/objdef.c **** /* no padding required: Bit entries within an array object may overlap byte borders*/
 217:../SSC/Src/objdef.c **** 
 218:../SSC/Src/objdef.c ****             /* we have to convert the size in bytes */
 219:../SSC/Src/objdef.c ****             size = BIT2BYTE(size);
 204              	 .loc 1 219 0
 205 005c FB68     	 ldr r3,[r7,#12]
 206 005e 0733     	 adds r3,r3,#7
 207 0060 DB08     	 lsrs r3,r3,#3
 208 0062 FB60     	 str r3,[r7,#12]
 220:../SSC/Src/objdef.c **** 
 221:../SSC/Src/objdef.c ****             if ( subindex == 0 )
 209              	 .loc 1 221 0
 210 0064 7B79     	 ldrb r3,[r7,#5]
 211 0066 002B     	 cmp r3,#0
 212 0068 02D1     	 bne .L11
 222:../SSC/Src/objdef.c ****             {
 223:../SSC/Src/objdef.c ****                 /* add size for subindex 0 (is transmitted as UINT16) */
 224:../SSC/Src/objdef.c ****                 size += 2;
 213              	 .loc 1 224 0
 214 006a FB68     	 ldr r3,[r7,#12]
 215 006c 0233     	 adds r3,r3,#2
 216 006e FB60     	 str r3,[r7,#12]
 217              	.L11:
 225:../SSC/Src/objdef.c ****             }
 226:../SSC/Src/objdef.c ****             return size;
 218              	 .loc 1 226 0
 219 0070 FB68     	 ldr r3,[r7,#12]
 220 0072 45E0     	 b .L9
 221              	.L10:
 222              	.LBB2:
 227:../SSC/Src/objdef.c ****         }
 228:../SSC/Src/objdef.c ****         else
 229:../SSC/Src/objdef.c ****         {
 230:../SSC/Src/objdef.c ****             UINT8 i;
 231:../SSC/Src/objdef.c **** 
 232:../SSC/Src/objdef.c ****             /* add the sizes of all entries */
 233:../SSC/Src/objdef.c ****             for (i = 1; i <= maxSubindex; i++)
 223              	 .loc 1 233 0
 224 0074 0123     	 movs r3,#1
 225 0076 FB72     	 strb r3,[r7,#11]
 226 0078 0FE0     	 b .L12
 227              	.L13:
 234:../SSC/Src/objdef.c ****             {
 235:../SSC/Src/objdef.c ****                 size += pObjEntry->pEntryDesc[i].BitLength;
 228              	 .loc 1 235 0 discriminator 3
 229 007a 3B68     	 ldr r3,[r7]
 230 007c 1969     	 ldr r1,[r3,#16]
 231 007e FA7A     	 ldrb r2,[r7,#11]
 232 0080 1346     	 mov r3,r2
 233 0082 5B00     	 lsls r3,r3,#1
 234 0084 1344     	 add r3,r3,r2
 235 0086 5B00     	 lsls r3,r3,#1
 236 0088 0B44     	 add r3,r3,r1
 237 008a 5B88     	 ldrh r3,[r3,#2]
 238 008c 1A46     	 mov r2,r3
 239 008e FB68     	 ldr r3,[r7,#12]
 240 0090 1344     	 add r3,r3,r2
 241 0092 FB60     	 str r3,[r7,#12]
 233:../SSC/Src/objdef.c ****             {
 242              	 .loc 1 233 0 discriminator 3
 243 0094 FB7A     	 ldrb r3,[r7,#11]
 244 0096 0133     	 adds r3,r3,#1
 245 0098 FB72     	 strb r3,[r7,#11]
 246              	.L12:
 233:../SSC/Src/objdef.c ****             {
 247              	 .loc 1 233 0 is_stmt 0 discriminator 1
 248 009a FA7A     	 ldrb r2,[r7,#11]
 249 009c 7B7A     	 ldrb r3,[r7,#9]
 250 009e 9A42     	 cmp r2,r3
 251 00a0 EBD9     	 bls .L13
 236:../SSC/Src/objdef.c ****             }
 237:../SSC/Src/objdef.c ****             /* we have to convert the size in bytes */
 238:../SSC/Src/objdef.c ****             size = BIT2BYTE(size);
 252              	 .loc 1 238 0 is_stmt 1
 253 00a2 FB68     	 ldr r3,[r7,#12]
 254 00a4 0733     	 adds r3,r3,#7
 255 00a6 DB08     	 lsrs r3,r3,#3
 256 00a8 FB60     	 str r3,[r7,#12]
 239:../SSC/Src/objdef.c **** 
 240:../SSC/Src/objdef.c ****             if ( subindex == 0 )
 257              	 .loc 1 240 0
 258 00aa 7B79     	 ldrb r3,[r7,#5]
 259 00ac 002B     	 cmp r3,#0
 260 00ae 02D1     	 bne .L14
 241:../SSC/Src/objdef.c ****             {
 242:../SSC/Src/objdef.c ****                 /* add size for subindex 0 (is transmitted as UINT16) */
 243:../SSC/Src/objdef.c ****                 size += 2;
 261              	 .loc 1 243 0
 262 00b0 FB68     	 ldr r3,[r7,#12]
 263 00b2 0233     	 adds r3,r3,#2
 264 00b4 FB60     	 str r3,[r7,#12]
 265              	.L14:
 244:../SSC/Src/objdef.c ****             }
 245:../SSC/Src/objdef.c ****             return size;
 266              	 .loc 1 245 0
 267 00b6 FB68     	 ldr r3,[r7,#12]
 268 00b8 22E0     	 b .L9
 269              	.L7:
 270              	.LBE2:
 246:../SSC/Src/objdef.c ****         }
 247:../SSC/Src/objdef.c ****     }
 248:../SSC/Src/objdef.c ****     else
 249:../SSC/Src/objdef.c ****     {
 250:../SSC/Src/objdef.c ****         if ( objCode == OBJCODE_VAR )
 271              	 .loc 1 250 0
 272 00ba BB7A     	 ldrb r3,[r7,#10]
 273 00bc 072B     	 cmp r3,#7
 274 00be 05D1     	 bne .L15
 251:../SSC/Src/objdef.c ****         {
 252:../SSC/Src/objdef.c ****             return (BIT2BYTE(pObjEntry->pEntryDesc->BitLength));
 275              	 .loc 1 252 0
 276 00c0 3B68     	 ldr r3,[r7]
 277 00c2 1B69     	 ldr r3,[r3,#16]
 278 00c4 5B88     	 ldrh r3,[r3,#2]
 279 00c6 0733     	 adds r3,r3,#7
 280 00c8 DB10     	 asrs r3,r3,#3
 281 00ca 19E0     	 b .L9
 282              	.L15:
 253:../SSC/Src/objdef.c **** 
 254:../SSC/Src/objdef.c ****         }
 255:../SSC/Src/objdef.c ****         else if ( subindex == 0 )
 283              	 .loc 1 255 0
 284 00cc 7B79     	 ldrb r3,[r7,#5]
 285 00ce 002B     	 cmp r3,#0
 286 00d0 01D1     	 bne .L16
 256:../SSC/Src/objdef.c ****         {
 257:../SSC/Src/objdef.c ****             /* for single access subindex 0 is transmitted as UINT8 */
 258:../SSC/Src/objdef.c ****             return 1;
 287              	 .loc 1 258 0
 288 00d2 0123     	 movs r3,#1
 289 00d4 14E0     	 b .L9
 290              	.L16:
 259:../SSC/Src/objdef.c ****         }
 260:../SSC/Src/objdef.c ****         else if((objCode == OBJCODE_ARR)
 291              	 .loc 1 260 0
 292 00d6 BB7A     	 ldrb r3,[r7,#10]
 293 00d8 082B     	 cmp r3,#8
 294 00da 06D1     	 bne .L17
 261:../SSC/Src/objdef.c ****             )
 262:../SSC/Src/objdef.c ****         {
 263:../SSC/Src/objdef.c ****             return (BIT2BYTE(pObjEntry->pEntryDesc[1].BitLength));
 295              	 .loc 1 263 0
 296 00dc 3B68     	 ldr r3,[r7]
 297 00de 1B69     	 ldr r3,[r3,#16]
 298 00e0 0633     	 adds r3,r3,#6
 299 00e2 5B88     	 ldrh r3,[r3,#2]
 300 00e4 0733     	 adds r3,r3,#7
 301 00e6 DB10     	 asrs r3,r3,#3
 302 00e8 0AE0     	 b .L9
 303              	.L17:
 264:../SSC/Src/objdef.c ****         }
 265:../SSC/Src/objdef.c ****         else
 266:../SSC/Src/objdef.c ****         {
 267:../SSC/Src/objdef.c ****                 return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
 304              	 .loc 1 267 0
 305 00ea 3B68     	 ldr r3,[r7]
 306 00ec 1969     	 ldr r1,[r3,#16]
 307 00ee 7A79     	 ldrb r2,[r7,#5]
 308 00f0 1346     	 mov r3,r2
 309 00f2 5B00     	 lsls r3,r3,#1
 310 00f4 1344     	 add r3,r3,r2
 311 00f6 5B00     	 lsls r3,r3,#1
 312 00f8 0B44     	 add r3,r3,r1
 313 00fa 5B88     	 ldrh r3,[r3,#2]
 314 00fc 0733     	 adds r3,r3,#7
 315 00fe DB10     	 asrs r3,r3,#3
 316              	.L9:
 268:../SSC/Src/objdef.c ****         }
 269:../SSC/Src/objdef.c ****     }
 270:../SSC/Src/objdef.c **** }
 317              	 .loc 1 270 0
 318 0100 1846     	 mov r0,r3
 319 0102 1437     	 adds r7,r7,#20
 320              	.LCFI8:
 321              	 .cfi_def_cfa_offset 4
 322 0104 BD46     	 mov sp,r7
 323              	.LCFI9:
 324              	 .cfi_def_cfa_register 13
 325              	 
 326 0106 5DF8047B 	 ldr r7,[sp],#4
 327              	.LCFI10:
 328              	 .cfi_restore 7
 329              	 .cfi_def_cfa_offset 0
 330 010a 7047     	 bx lr
 331              	 .cfi_endproc
 332              	.LFE173:
 334              	 .section .text.OBJ_CopyNumberToString,"ax",%progbits
 335              	 .align 2
 336              	 .global OBJ_CopyNumberToString
 337              	 .thumb
 338              	 .thumb_func
 340              	OBJ_CopyNumberToString:
 341              	.LFB174:
 271:../SSC/Src/objdef.c **** 
 272:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 273:../SSC/Src/objdef.c **** /**
 274:../SSC/Src/objdef.c ****  \param     pStr         Pointer to a string
 275:../SSC/Src/objdef.c ****  \param  Number   Number to be included in the string
 276:../SSC/Src/objdef.c **** 
 277:../SSC/Src/objdef.c ****  \brief    The function copies the Number in the string pStr,
 278:../SSC/Src/objdef.c ****          which shall be initialized with 000
 279:../SSC/Src/objdef.c **** 
 280:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 281:../SSC/Src/objdef.c **** 
 282:../SSC/Src/objdef.c **** void OBJ_CopyNumberToString(UCHAR MBXMEM *pStr, UINT8 Number)
 283:../SSC/Src/objdef.c **** {
 342              	 .loc 1 283 0
 343              	 .cfi_startproc
 344              	 
 345              	 
 346              	 
 347 0000 90B4     	 push {r4,r7}
 348              	.LCFI11:
 349              	 .cfi_def_cfa_offset 8
 350              	 .cfi_offset 4,-8
 351              	 .cfi_offset 7,-4
 352 0002 84B0     	 sub sp,sp,#16
 353              	.LCFI12:
 354              	 .cfi_def_cfa_offset 24
 355 0004 00AF     	 add r7,sp,#0
 356              	.LCFI13:
 357              	 .cfi_def_cfa_register 7
 358 0006 7860     	 str r0,[r7,#4]
 359 0008 0B46     	 mov r3,r1
 360 000a FB70     	 strb r3,[r7,#3]
 284:../SSC/Src/objdef.c ****     UINT8 Modulo;
 285:../SSC/Src/objdef.c **** 
 286:../SSC/Src/objdef.c ****     pStr[2] = '0';
 361              	 .loc 1 286 0
 362 000c 7B68     	 ldr r3,[r7,#4]
 363 000e 0233     	 adds r3,r3,#2
 364 0010 3022     	 movs r2,#48
 365 0012 1A70     	 strb r2,[r3]
 287:../SSC/Src/objdef.c ****     pStr[0] += (Number / 100);
 366              	 .loc 1 287 0
 367 0014 7B68     	 ldr r3,[r7,#4]
 368 0016 1A78     	 ldrb r2,[r3]
 369 0018 FB78     	 ldrb r3,[r7,#3]
 370 001a 1C49     	 ldr r1,.L19
 371 001c A1FB0313 	 umull r1,r3,r1,r3
 372 0020 5B09     	 lsrs r3,r3,#5
 373 0022 DBB2     	 uxtb r3,r3
 374 0024 1344     	 add r3,r3,r2
 375 0026 DAB2     	 uxtb r2,r3
 376 0028 7B68     	 ldr r3,[r7,#4]
 377 002a 1A70     	 strb r2,[r3]
 288:../SSC/Src/objdef.c ****     Modulo = Number % 100;
 378              	 .loc 1 288 0
 379 002c FB78     	 ldrb r3,[r7,#3]
 380 002e 174A     	 ldr r2,.L19
 381 0030 A2FB0312 	 umull r1,r2,r2,r3
 382 0034 5209     	 lsrs r2,r2,#5
 383 0036 6421     	 movs r1,#100
 384 0038 01FB02F2 	 mul r2,r1,r2
 385 003c 9B1A     	 subs r3,r3,r2
 386 003e FB73     	 strb r3,[r7,#15]
 289:../SSC/Src/objdef.c ****     pStr[1] += (Modulo / 10);
 387              	 .loc 1 289 0
 388 0040 7B68     	 ldr r3,[r7,#4]
 389 0042 0133     	 adds r3,r3,#1
 390 0044 7A68     	 ldr r2,[r7,#4]
 391 0046 0132     	 adds r2,r2,#1
 392 0048 1178     	 ldrb r1,[r2]
 393 004a FA7B     	 ldrb r2,[r7,#15]
 394 004c 1048     	 ldr r0,.L19+4
 395 004e A0FB0202 	 umull r0,r2,r0,r2
 396 0052 D208     	 lsrs r2,r2,#3
 397 0054 D2B2     	 uxtb r2,r2
 398 0056 0A44     	 add r2,r2,r1
 399 0058 D2B2     	 uxtb r2,r2
 400 005a 1A70     	 strb r2,[r3]
 290:../SSC/Src/objdef.c ****     pStr[2] += (Modulo % 10);
 401              	 .loc 1 290 0
 402 005c 7B68     	 ldr r3,[r7,#4]
 403 005e 981C     	 adds r0,r3,#2
 404 0060 7B68     	 ldr r3,[r7,#4]
 405 0062 0233     	 adds r3,r3,#2
 406 0064 1C78     	 ldrb r4,[r3]
 407 0066 FA7B     	 ldrb r2,[r7,#15]
 408 0068 094B     	 ldr r3,.L19+4
 409 006a A3FB0213 	 umull r1,r3,r3,r2
 410 006e D908     	 lsrs r1,r3,#3
 411 0070 0B46     	 mov r3,r1
 412 0072 9B00     	 lsls r3,r3,#2
 413 0074 0B44     	 add r3,r3,r1
 414 0076 5B00     	 lsls r3,r3,#1
 415 0078 D31A     	 subs r3,r2,r3
 416 007a DBB2     	 uxtb r3,r3
 417 007c 2344     	 add r3,r3,r4
 418 007e DBB2     	 uxtb r3,r3
 419 0080 0370     	 strb r3,[r0]
 291:../SSC/Src/objdef.c **** }
 420              	 .loc 1 291 0
 421 0082 1037     	 adds r7,r7,#16
 422              	.LCFI14:
 423              	 .cfi_def_cfa_offset 8
 424 0084 BD46     	 mov sp,r7
 425              	.LCFI15:
 426              	 .cfi_def_cfa_register 13
 427              	 
 428 0086 90BC     	 pop {r4,r7}
 429              	.LCFI16:
 430              	 .cfi_restore 7
 431              	 .cfi_restore 4
 432              	 .cfi_def_cfa_offset 0
 433 0088 7047     	 bx lr
 434              	.L20:
 435 008a 00BF     	 .align 2
 436              	.L19:
 437 008c 1F85EB51 	 .word 1374389535
 438 0090 CDCCCCCC 	 .word -858993459
 439              	 .cfi_endproc
 440              	.LFE174:
 442              	 .section .text.OBJ_GetNoOfObjects,"ax",%progbits
 443              	 .align 2
 444              	 .global OBJ_GetNoOfObjects
 445              	 .thumb
 446              	 .thumb_func
 448              	OBJ_GetNoOfObjects:
 449              	.LFB175:
 292:../SSC/Src/objdef.c **** 
 293:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 294:../SSC/Src/objdef.c **** /**
 295:../SSC/Src/objdef.c ****  \param     listType requested listType (0=all objects, 1=RxPDO mappable objects,
 296:../SSC/Src/objdef.c ****                         2=TxPDO mappable objects, 3=backup objects, 4=setting objects)
 297:../SSC/Src/objdef.c **** 
 298:../SSC/Src/objdef.c ****  \return Number of objects of the requested list type
 299:../SSC/Src/objdef.c **** 
 300:../SSC/Src/objdef.c ****  \brief    The function counts the number of objects of the requested list type
 301:../SSC/Src/objdef.c **** 
 302:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 303:../SSC/Src/objdef.c **** 
 304:../SSC/Src/objdef.c **** UINT16    OBJ_GetNoOfObjects(UINT8 listType)
 305:../SSC/Src/objdef.c **** {
 450              	 .loc 1 305 0
 451              	 .cfi_startproc
 452              	 
 453              	 
 454 0000 80B5     	 push {r7,lr}
 455              	.LCFI17:
 456              	 .cfi_def_cfa_offset 8
 457              	 .cfi_offset 7,-8
 458              	 .cfi_offset 14,-4
 459 0002 86B0     	 sub sp,sp,#24
 460              	.LCFI18:
 461              	 .cfi_def_cfa_offset 32
 462 0004 00AF     	 add r7,sp,#0
 463              	.LCFI19:
 464              	 .cfi_def_cfa_register 7
 465 0006 0346     	 mov r3,r0
 466 0008 FB71     	 strb r3,[r7,#7]
 306:../SSC/Src/objdef.c ****     /* the variable listFlags contains the mask used for the ObjAccess in the Entry-Desc
 307:../SSC/Src/objdef.c ****        see the structure TSDOINFOENTRYDESC in sdoserv.h, listType = 0 indicates that
 308:../SSC/Src/objdef.c ****        all objects has to be counted */
 309:../SSC/Src/objdef.c ****     
 310:../SSC/Src/objdef.c ****     UINT16 listFlags = 0x0020 << listType;
 467              	 .loc 1 310 0
 468 000a FB79     	 ldrb r3,[r7,#7]
 469 000c 2022     	 movs r2,#32
 470 000e 02FA03F3 	 lsl r3,r2,r3
 471 0012 BB81     	 strh r3,[r7,#12]
 311:../SSC/Src/objdef.c ****     
 312:../SSC/Src/objdef.c ****     /* set pObjEntry to the beginning of the object dictionary */
 313:../SSC/Src/objdef.c ****     OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
 472              	 .loc 1 313 0
 473 0014 FFF7FEFF 	 bl COE_GetObjectDictionary
 474 0018 7861     	 str r0,[r7,#20]
 314:../SSC/Src/objdef.c ****     UINT16 n = 0;
 475              	 .loc 1 314 0
 476 001a 0023     	 movs r3,#0
 477 001c 7B82     	 strh r3,[r7,#18]
 315:../SSC/Src/objdef.c **** 
 316:../SSC/Src/objdef.c **** 
 317:../SSC/Src/objdef.c ****     while (pObjEntry != NULL)
 478              	 .loc 1 317 0
 479 001e 32E0     	 b .L22
 480              	.L28:
 318:../SSC/Src/objdef.c ****     {
 319:../SSC/Src/objdef.c ****         /* count the objects of the requested list type */
 320:../SSC/Src/objdef.c ****         if ( pObjEntry->Index >= 0x1000 )
 481              	 .loc 1 320 0
 482 0020 7B69     	 ldr r3,[r7,#20]
 483 0022 1B89     	 ldrh r3,[r3,#8]
 484 0024 B3F5805F 	 cmp r3,#4096
 485 0028 2AD3     	 bcc .L23
 486              	.LBB3:
 321:../SSC/Src/objdef.c ****         {
 322:../SSC/Src/objdef.c ****             UINT8 t = listType;
 487              	 .loc 1 322 0
 488 002a FB79     	 ldrb r3,[r7,#7]
 489 002c 7B74     	 strb r3,[r7,#17]
 323:../SSC/Src/objdef.c ****             if ( t )
 490              	 .loc 1 323 0
 491 002e 7B7C     	 ldrb r3,[r7,#17]
 492 0030 002B     	 cmp r3,#0
 493 0032 1FD0     	 beq .L24
 494              	.LBB4:
 324:../SSC/Src/objdef.c ****             {
 325:../SSC/Src/objdef.c ****                 UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJ
 495              	 .loc 1 325 0
 496 0034 7B69     	 ldr r3,[r7,#20]
 497 0036 9B89     	 ldrh r3,[r3,#12]
 498 0038 FB72     	 strb r3,[r7,#11]
 326:../SSC/Src/objdef.c ****                 UINT16 i = 0;
 499              	 .loc 1 326 0
 500 003a 0023     	 movs r3,#0
 501 003c FB81     	 strh r3,[r7,#14]
 327:../SSC/Src/objdef.c **** 
 328:../SSC/Src/objdef.c ****                 while ( t && i <= maxSubindex )
 502              	 .loc 1 328 0
 503 003e 11E0     	 b .L25
 504              	.L27:
 329:../SSC/Src/objdef.c ****                 {
 330:../SSC/Src/objdef.c ****                     if ( OBJ_GetEntryDesc(pObjEntry,(UINT8) i)->ObjAccess & listFlags )
 505              	 .loc 1 330 0
 506 0040 FB89     	 ldrh r3,[r7,#14]
 507 0042 DBB2     	 uxtb r3,r3
 508 0044 7869     	 ldr r0,[r7,#20]
 509 0046 1946     	 mov r1,r3
 510 0048 FFF7FEFF 	 bl OBJ_GetEntryDesc
 511 004c 0346     	 mov r3,r0
 512 004e 9A88     	 ldrh r2,[r3,#4]
 513 0050 BB89     	 ldrh r3,[r7,#12]
 514 0052 1340     	 ands r3,r3,r2
 515 0054 9BB2     	 uxth r3,r3
 516 0056 002B     	 cmp r3,#0
 517 0058 01D0     	 beq .L26
 331:../SSC/Src/objdef.c ****                         t = 0;
 518              	 .loc 1 331 0
 519 005a 0023     	 movs r3,#0
 520 005c 7B74     	 strb r3,[r7,#17]
 521              	.L26:
 332:../SSC/Src/objdef.c ****                     i++;
 522              	 .loc 1 332 0
 523 005e FB89     	 ldrh r3,[r7,#14]
 524 0060 0133     	 adds r3,r3,#1
 525 0062 FB81     	 strh r3,[r7,#14]
 526              	.L25:
 328:../SSC/Src/objdef.c ****                 {
 527              	 .loc 1 328 0
 528 0064 7B7C     	 ldrb r3,[r7,#17]
 529 0066 002B     	 cmp r3,#0
 530 0068 04D0     	 beq .L24
 328:../SSC/Src/objdef.c ****                 {
 531              	 .loc 1 328 0 is_stmt 0 discriminator 1
 532 006a FB7A     	 ldrb r3,[r7,#11]
 533 006c 9BB2     	 uxth r3,r3
 534 006e FA89     	 ldrh r2,[r7,#14]
 535 0070 9A42     	 cmp r2,r3
 536 0072 E5D9     	 bls .L27
 537              	.L24:
 538              	.LBE4:
 333:../SSC/Src/objdef.c ****                 }
 334:../SSC/Src/objdef.c ****             }
 335:../SSC/Src/objdef.c ****             if ( !t )
 539              	 .loc 1 335 0 is_stmt 1
 540 0074 7B7C     	 ldrb r3,[r7,#17]
 541 0076 002B     	 cmp r3,#0
 542 0078 02D1     	 bne .L23
 336:../SSC/Src/objdef.c ****             {
 337:../SSC/Src/objdef.c ****                 /* object from listType found */
 338:../SSC/Src/objdef.c ****                 n++;
 543              	 .loc 1 338 0
 544 007a 7B8A     	 ldrh r3,[r7,#18]
 545 007c 0133     	 adds r3,r3,#1
 546 007e 7B82     	 strh r3,[r7,#18]
 547              	.L23:
 548              	.LBE3:
 339:../SSC/Src/objdef.c ****             }
 340:../SSC/Src/objdef.c ****         }
 341:../SSC/Src/objdef.c ****         /* next object in object dictionary */
 342:../SSC/Src/objdef.c ****         pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
 549              	 .loc 1 342 0
 550 0080 7B69     	 ldr r3,[r7,#20]
 551 0082 5B68     	 ldr r3,[r3,#4]
 552 0084 7B61     	 str r3,[r7,#20]
 553              	.L22:
 317:../SSC/Src/objdef.c ****     {
 554              	 .loc 1 317 0
 555 0086 7B69     	 ldr r3,[r7,#20]
 556 0088 002B     	 cmp r3,#0
 557 008a C9D1     	 bne .L28
 343:../SSC/Src/objdef.c ****     }
 344:../SSC/Src/objdef.c **** 
 345:../SSC/Src/objdef.c ****     return n;
 558              	 .loc 1 345 0
 559 008c 7B8A     	 ldrh r3,[r7,#18]
 346:../SSC/Src/objdef.c **** }
 560              	 .loc 1 346 0
 561 008e 1846     	 mov r0,r3
 562 0090 1837     	 adds r7,r7,#24
 563              	.LCFI20:
 564              	 .cfi_def_cfa_offset 8
 565 0092 BD46     	 mov sp,r7
 566              	.LCFI21:
 567              	 .cfi_def_cfa_register 13
 568              	 
 569 0094 80BD     	 pop {r7,pc}
 570              	 .cfi_endproc
 571              	.LFE175:
 573 0096 00BF     	 .section .text.OBJ_GetObjectList,"ax",%progbits
 574              	 .align 2
 575              	 .global OBJ_GetObjectList
 576              	 .thumb
 577              	 .thumb_func
 579              	OBJ_GetObjectList:
 580              	.LFB176:
 347:../SSC/Src/objdef.c **** 
 348:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 349:../SSC/Src/objdef.c **** /**
 350:../SSC/Src/objdef.c ****  \param     listType 	Requested listType (0=all objects, 1=RxPDO mappable objects,
 351:../SSC/Src/objdef.c ****                         2=TxPDO mappable objects, 3=backup objects, 4=setting objects)
 352:../SSC/Src/objdef.c ****  \param     pIndex     	Pointer to the next Index of the object list to copied in the mailbox buffe
 353:../SSC/Src/objdef.c ****                          has to adapted    at the end of the function
 354:../SSC/Src/objdef.c ****  \param     size        Size of the available mailbox buffer
 355:../SSC/Src/objdef.c ****  \param     pData     	Pointer to the mailbox buffer where (the part of) the object list requested 
 356:../SSC/Src/objdef.c ****  \param     pAbort    	Pointer to abortCode
 357:../SSC/Src/objdef.c **** 
 358:../SSC/Src/objdef.c ****  \return 	Size of the available mailbox buffer which was not copied to
 359:../SSC/Src/objdef.c **** 
 360:../SSC/Src/objdef.c ****  \brief    The function copies (the part of) the object list in the mailbox buffer
 361:../SSC/Src/objdef.c **** 
 362:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 363:../SSC/Src/objdef.c **** UINT16    OBJ_GetObjectList(UINT16 listType, UINT16 *pIndex, UINT16 size, UINT16 MBXMEM *pData,UINT
 364:../SSC/Src/objdef.c **** {
 581              	 .loc 1 364 0
 582              	 .cfi_startproc
 583              	 
 584              	 
 585 0000 80B5     	 push {r7,lr}
 586              	.LCFI22:
 587              	 .cfi_def_cfa_offset 8
 588              	 .cfi_offset 7,-8
 589              	 .cfi_offset 14,-4
 590 0002 88B0     	 sub sp,sp,#32
 591              	.LCFI23:
 592              	 .cfi_def_cfa_offset 40
 593 0004 00AF     	 add r7,sp,#0
 594              	.LCFI24:
 595              	 .cfi_def_cfa_register 7
 596 0006 B960     	 str r1,[r7,#8]
 597 0008 7B60     	 str r3,[r7,#4]
 598 000a 0346     	 mov r3,r0
 599 000c FB81     	 strh r3,[r7,#14]
 600 000e 1346     	 mov r3,r2
 601 0010 BB81     	 strh r3,[r7,#12]
 365:../SSC/Src/objdef.c ****     /* the variable listFlags contains the mask used for the ObjAccess in the Entry-Desc
 366:../SSC/Src/objdef.c ****        see the structure TSDOINFOENTRYDESC in sdoserv.h, listType = 0 indicates that
 367:../SSC/Src/objdef.c ****        all objects has to be counted */
 368:../SSC/Src/objdef.c ****     UINT16 listFlags = 0x0020 << listType;
 602              	 .loc 1 368 0
 603 0012 FB89     	 ldrh r3,[r7,#14]
 604 0014 2022     	 movs r2,#32
 605 0016 02FA03F3 	 lsl r3,r2,r3
 606 001a FB82     	 strh r3,[r7,#22]
 369:../SSC/Src/objdef.c ****     OBJCONST TOBJECT OBJMEM * pObjEntry;
 370:../SSC/Src/objdef.c **** 
 371:../SSC/Src/objdef.c **** 
 372:../SSC/Src/objdef.c ****     if ( pIndex[0] == 0x1000 )
 607              	 .loc 1 372 0
 608 001c BB68     	 ldr r3,[r7,#8]
 609 001e 1B88     	 ldrh r3,[r3]
 610 0020 B3F5805F 	 cmp r3,#4096
 611 0024 0CD1     	 bne .L31
 373:../SSC/Src/objdef.c ****     {
 374:../SSC/Src/objdef.c ****         /* beginning of object list, set pObjEntry to the beginning of the object dictionary */
 375:../SSC/Src/objdef.c ****        pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
 612              	 .loc 1 375 0
 613 0026 FFF7FEFF 	 bl COE_GetObjectDictionary
 614 002a F861     	 str r0,[r7,#28]
 376:../SSC/Src/objdef.c ****         // set abort code if no object dictionary is available
 377:../SSC/Src/objdef.c ****         if((pObjEntry == NULL) && (pAbort != NULL))
 615              	 .loc 1 377 0
 616 002c FB69     	 ldr r3,[r7,#28]
 617 002e 002B     	 cmp r3,#0
 618 0030 09D1     	 bne .L33
 619              	 .loc 1 377 0 is_stmt 0 discriminator 1
 620 0032 BB6A     	 ldr r3,[r7,#40]
 621 0034 002B     	 cmp r3,#0
 622 0036 06D0     	 beq .L33
 378:../SSC/Src/objdef.c ****         {
 379:../SSC/Src/objdef.c ****             *pAbort = ABORTIDX_NO_OBJECT_DICTIONARY_IS_PRESENT;
 623              	 .loc 1 379 0 is_stmt 1
 624 0038 BB6A     	 ldr r3,[r7,#40]
 625 003a 1B22     	 movs r2,#27
 626 003c 1A70     	 strb r2,[r3]
 627 003e 02E0     	 b .L33
 628              	.L31:
 380:../SSC/Src/objdef.c ****         }
 381:../SSC/Src/objdef.c ****     }
 382:../SSC/Src/objdef.c ****     else
 383:../SSC/Src/objdef.c ****     {
 384:../SSC/Src/objdef.c ****         /* next fragment, the next object to be handled was stored in pSdoInfoObjEntry */
 385:../SSC/Src/objdef.c ****         pObjEntry = pSdoInfoObjEntry;
 629              	 .loc 1 385 0
 630 0040 2C4B     	 ldr r3,.L45
 631 0042 1B68     	 ldr r3,[r3]
 632 0044 FB61     	 str r3,[r7,#28]
 633              	.L33:
 386:../SSC/Src/objdef.c ****     }
 387:../SSC/Src/objdef.c **** 
 388:../SSC/Src/objdef.c ****     if ( pObjEntry != NULL )
 634              	 .loc 1 388 0
 635 0046 FB69     	 ldr r3,[r7,#28]
 636 0048 002B     	 cmp r3,#0
 637 004a 3ED0     	 beq .L34
 389:../SSC/Src/objdef.c ****     {
 390:../SSC/Src/objdef.c ****         while (pObjEntry != NULL && size > 1 )
 638              	 .loc 1 390 0
 639 004c 37E0     	 b .L35
 640              	.L41:
 391:../SSC/Src/objdef.c ****         {
 392:../SSC/Src/objdef.c ****             /* get the next index of the requested object list if there is enough space in the mail
 393:../SSC/Src/objdef.c ****             if ( pObjEntry->Index >= 0x1000 )
 641              	 .loc 1 393 0
 642 004e FB69     	 ldr r3,[r7,#28]
 643 0050 1B89     	 ldrh r3,[r3,#8]
 644 0052 B3F5805F 	 cmp r3,#4096
 645 0056 2FD3     	 bcc .L36
 646              	.LBB5:
 394:../SSC/Src/objdef.c ****             {
 395:../SSC/Src/objdef.c ****                 /* UINT8 was changed to UINT16 */
 396:../SSC/Src/objdef.c ****                 UINT16 t = listType;
 647              	 .loc 1 396 0
 648 0058 FB89     	 ldrh r3,[r7,#14]
 649 005a 7B83     	 strh r3,[r7,#26]
 397:../SSC/Src/objdef.c ****                 if ( t )
 650              	 .loc 1 397 0
 651 005c 7B8B     	 ldrh r3,[r7,#26]
 652 005e 002B     	 cmp r3,#0
 653 0060 1DD0     	 beq .L37
 654              	.LBB6:
 398:../SSC/Src/objdef.c ****                 {
 399:../SSC/Src/objdef.c ****                     UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >>
 655              	 .loc 1 399 0
 656 0062 FB69     	 ldr r3,[r7,#28]
 657 0064 9B89     	 ldrh r3,[r3,#12]
 658 0066 7B75     	 strb r3,[r7,#21]
 400:../SSC/Src/objdef.c ****                     UINT8 i = 0;
 659              	 .loc 1 400 0
 660 0068 0023     	 movs r3,#0
 661 006a 7B76     	 strb r3,[r7,#25]
 401:../SSC/Src/objdef.c **** 
 402:../SSC/Src/objdef.c ****                     while ( t && i <= maxSubindex )
 662              	 .loc 1 402 0
 663 006c 10E0     	 b .L38
 664              	.L40:
 403:../SSC/Src/objdef.c ****                     {
 404:../SSC/Src/objdef.c ****                         if ( OBJ_GetEntryDesc(pObjEntry, i)->ObjAccess & listFlags )
 665              	 .loc 1 404 0
 666 006e 7B7E     	 ldrb r3,[r7,#25]
 667 0070 F869     	 ldr r0,[r7,#28]
 668 0072 1946     	 mov r1,r3
 669 0074 FFF7FEFF 	 bl OBJ_GetEntryDesc
 670 0078 0346     	 mov r3,r0
 671 007a 9A88     	 ldrh r2,[r3,#4]
 672 007c FB8A     	 ldrh r3,[r7,#22]
 673 007e 1340     	 ands r3,r3,r2
 674 0080 9BB2     	 uxth r3,r3
 675 0082 002B     	 cmp r3,#0
 676 0084 01D0     	 beq .L39
 405:../SSC/Src/objdef.c ****                             t = 0;
 677              	 .loc 1 405 0
 678 0086 0023     	 movs r3,#0
 679 0088 7B83     	 strh r3,[r7,#26]
 680              	.L39:
 406:../SSC/Src/objdef.c ****                         i++;
 681              	 .loc 1 406 0
 682 008a 7B7E     	 ldrb r3,[r7,#25]
 683 008c 0133     	 adds r3,r3,#1
 684 008e 7B76     	 strb r3,[r7,#25]
 685              	.L38:
 402:../SSC/Src/objdef.c ****                     {
 686              	 .loc 1 402 0
 687 0090 7B8B     	 ldrh r3,[r7,#26]
 688 0092 002B     	 cmp r3,#0
 689 0094 03D0     	 beq .L37
 402:../SSC/Src/objdef.c ****                     {
 690              	 .loc 1 402 0 is_stmt 0 discriminator 1
 691 0096 7A7E     	 ldrb r2,[r7,#25]
 692 0098 7B7D     	 ldrb r3,[r7,#21]
 693 009a 9A42     	 cmp r2,r3
 694 009c E7D9     	 bls .L40
 695              	.L37:
 696              	.LBE6:
 407:../SSC/Src/objdef.c ****                     }
 408:../SSC/Src/objdef.c ****                 }
 409:../SSC/Src/objdef.c ****                 if ( !t )
 697              	 .loc 1 409 0 is_stmt 1
 698 009e 7B8B     	 ldrh r3,[r7,#26]
 699 00a0 002B     	 cmp r3,#0
 700 00a2 09D1     	 bne .L36
 410:../SSC/Src/objdef.c ****                 {
 411:../SSC/Src/objdef.c ****                     /* store the index in the mailbox buffer */
 412:../SSC/Src/objdef.c ****                     *pData = SWAPWORD(pObjEntry->Index);
 701              	 .loc 1 412 0
 702 00a4 FB69     	 ldr r3,[r7,#28]
 703 00a6 1A89     	 ldrh r2,[r3,#8]
 704 00a8 7B68     	 ldr r3,[r7,#4]
 705 00aa 1A80     	 strh r2,[r3]
 413:../SSC/Src/objdef.c ****                     pData++;
 706              	 .loc 1 413 0
 707 00ac 7B68     	 ldr r3,[r7,#4]
 708 00ae 0233     	 adds r3,r3,#2
 709 00b0 7B60     	 str r3,[r7,#4]
 414:../SSC/Src/objdef.c ****                     size -= 2;
 710              	 .loc 1 414 0
 711 00b2 BB89     	 ldrh r3,[r7,#12]
 712 00b4 023B     	 subs r3,r3,#2
 713 00b6 BB81     	 strh r3,[r7,#12]
 714              	.L36:
 715              	.LBE5:
 415:../SSC/Src/objdef.c ****                 }
 416:../SSC/Src/objdef.c ****             }
 417:../SSC/Src/objdef.c ****         pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
 716              	 .loc 1 417 0
 717 00b8 FB69     	 ldr r3,[r7,#28]
 718 00ba 5B68     	 ldr r3,[r3,#4]
 719 00bc FB61     	 str r3,[r7,#28]
 720              	.L35:
 390:../SSC/Src/objdef.c ****         {
 721              	 .loc 1 390 0
 722 00be FB69     	 ldr r3,[r7,#28]
 723 00c0 002B     	 cmp r3,#0
 724 00c2 02D0     	 beq .L34
 390:../SSC/Src/objdef.c ****         {
 725              	 .loc 1 390 0 is_stmt 0 discriminator 1
 726 00c4 BB89     	 ldrh r3,[r7,#12]
 727 00c6 012B     	 cmp r3,#1
 728 00c8 C1D8     	 bhi .L41
 729              	.L34:
 418:../SSC/Src/objdef.c ****         }
 419:../SSC/Src/objdef.c ****     }
 420:../SSC/Src/objdef.c **** 
 421:../SSC/Src/objdef.c ****         /* return the next Index to be handled */
 422:../SSC/Src/objdef.c ****         if(pObjEntry != NULL)
 730              	 .loc 1 422 0 is_stmt 1
 731 00ca FB69     	 ldr r3,[r7,#28]
 732 00cc 002B     	 cmp r3,#0
 733 00ce 04D0     	 beq .L42
 423:../SSC/Src/objdef.c ****         {
 424:../SSC/Src/objdef.c ****             pIndex[0] = pObjEntry->Index;
 734              	 .loc 1 424 0
 735 00d0 FB69     	 ldr r3,[r7,#28]
 736 00d2 1A89     	 ldrh r2,[r3,#8]
 737 00d4 BB68     	 ldr r3,[r7,#8]
 738 00d6 1A80     	 strh r2,[r3]
 739 00d8 03E0     	 b .L43
 740              	.L42:
 425:../SSC/Src/objdef.c ****         }
 426:../SSC/Src/objdef.c ****         else
 427:../SSC/Src/objdef.c ****         {
 428:../SSC/Src/objdef.c ****             /*last entry reached*/
 429:../SSC/Src/objdef.c ****             pIndex[0] = 0xFFFF;
 741              	 .loc 1 429 0
 742 00da BB68     	 ldr r3,[r7,#8]
 743 00dc 4FF6FF72 	 movw r2,#65535
 744 00e0 1A80     	 strh r2,[r3]
 745              	.L43:
 430:../SSC/Src/objdef.c ****         }
 431:../SSC/Src/objdef.c **** 
 432:../SSC/Src/objdef.c ****     /* store object description pointer and index for next fragment */
 433:../SSC/Src/objdef.c ****     pSdoInfoObjEntry = pObjEntry;
 746              	 .loc 1 433 0
 747 00e2 044A     	 ldr r2,.L45
 748 00e4 FB69     	 ldr r3,[r7,#28]
 749 00e6 1360     	 str r3,[r2]
 434:../SSC/Src/objdef.c **** 
 435:../SSC/Src/objdef.c ****     /* return the size of the available mailbox buffer which was not copied to */
 436:../SSC/Src/objdef.c ****     return size;
 750              	 .loc 1 436 0
 751 00e8 BB89     	 ldrh r3,[r7,#12]
 437:../SSC/Src/objdef.c **** }
 752              	 .loc 1 437 0
 753 00ea 1846     	 mov r0,r3
 754 00ec 2037     	 adds r7,r7,#32
 755              	.LCFI25:
 756              	 .cfi_def_cfa_offset 8
 757 00ee BD46     	 mov sp,r7
 758              	.LCFI26:
 759              	 .cfi_def_cfa_register 13
 760              	 
 761 00f0 80BD     	 pop {r7,pc}
 762              	.L46:
 763 00f2 00BF     	 .align 2
 764              	.L45:
 765 00f4 00000000 	 .word pSdoInfoObjEntry
 766              	 .cfi_endproc
 767              	.LFE176:
 769              	 .section .text.OBJ_GetDesc,"ax",%progbits
 770              	 .align 2
 771              	 .global OBJ_GetDesc
 772              	 .thumb
 773              	 .thumb_func
 775              	OBJ_GetDesc:
 776              	.LFB177:
 438:../SSC/Src/objdef.c **** 
 439:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 440:../SSC/Src/objdef.c **** /**
 441:../SSC/Src/objdef.c ****  \param     index     Indicates the index of the dictionary object.
 442:../SSC/Src/objdef.c ****  \param  	subindex  Indicates the subindex of the dictionary object.
 443:../SSC/Src/objdef.c ****                         Subindex 0xff returns the description of the whole object ( the name of
 444:../SSC/Src/objdef.c ****                         the object ).
 445:../SSC/Src/objdef.c ****                         Subindex 0x00 returns the description of the subindex 0 and so on.
 446:../SSC/Src/objdef.c ****  \param     pObjEntry Is a handle to the dictionary object ( for faster access ) or NULL.						
 447:../SSC/Src/objdef.c ****  \param    pData        Is the memory field for the description string or NULL ( if the size of
 448:../SSC/Src/objdef.c ****                         string is unknown ):
 449:../SSC/Src/objdef.c **** 
 450:../SSC/Src/objdef.c ****  \return    The size in bytes of the description string (without null termination byte ).
 451:../SSC/Src/objdef.c ****             0 will be returned if a description for the indicated entry was not found.
 452:../SSC/Src/objdef.c **** 
 453:../SSC/Src/objdef.c ****  \brief    The function returns size and description string of the requested entry.
 454:../SSC/Src/objdef.c **** 
 455:../SSC/Src/objdef.c ****             Its possible to define all description strings of one entry ( including the name
 456:../SSC/Src/objdef.c ****             of the object ) in one structure:        <br>
 457:../SSC/Src/objdef.c ****             {                                                    <br>
 458:../SSC/Src/objdef.c ****                 name_of_object with index,              <br>
 459:../SSC/Src/objdef.c ****                 description_of_subindex0,                <br>
 460:../SSC/Src/objdef.c ****                 .                                                <br>
 461:../SSC/Src/objdef.c ****                 description_of_subindexN,                <br>
 462:../SSC/Src/objdef.c ****                 0xFF                                            <br>
 463:../SSC/Src/objdef.c ****             }
 464:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 465:../SSC/Src/objdef.c **** 
 466:../SSC/Src/objdef.c **** UINT16 OBJ_GetDesc( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXME
 467:../SSC/Src/objdef.c **** {
 777              	 .loc 1 467 0
 778              	 .cfi_startproc
 779              	 
 780              	 
 781 0000 90B5     	 push {r4,r7,lr}
 782              	.LCFI27:
 783              	 .cfi_def_cfa_offset 12
 784              	 .cfi_offset 4,-12
 785              	 .cfi_offset 7,-8
 786              	 .cfi_offset 14,-4
 787 0002 8DB0     	 sub sp,sp,#52
 788              	.LCFI28:
 789              	 .cfi_def_cfa_offset 64
 790 0004 00AF     	 add r7,sp,#0
 791              	.LCFI29:
 792              	 .cfi_def_cfa_register 7
 793 0006 BA60     	 str r2,[r7,#8]
 794 0008 7B60     	 str r3,[r7,#4]
 795 000a 0346     	 mov r3,r0
 796 000c FB81     	 strh r3,[r7,#14]
 797 000e 0B46     	 mov r3,r1
 798 0010 7B73     	 strb r3,[r7,#13]
 468:../SSC/Src/objdef.c ****     UINT16 strSize = 0;
 799              	 .loc 1 468 0
 800 0012 0023     	 movs r3,#0
 801 0014 FB85     	 strh r3,[r7,#46]
 469:../SSC/Src/objdef.c ****     OBJCONST UCHAR OBJMEM * pDesc = (OBJCONST UCHAR OBJMEM *) pObjEntry->pName;
 802              	 .loc 1 469 0
 803 0016 BB68     	 ldr r3,[r7,#8]
 804 0018 5B69     	 ldr r3,[r3,#20]
 805 001a 7B62     	 str r3,[r7,#36]
 470:../SSC/Src/objdef.c **** /* get the information of ObjCode and MaxSubindex in local variables to support different types of 
 471:../SSC/Src/objdef.c ****     UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 806              	 .loc 1 471 0
 807 001c BB68     	 ldr r3,[r7,#8]
 808 001e 9B89     	 ldrh r3,[r3,#12]
 809 0020 03F47063 	 and r3,r3,#3840
 810 0024 1B12     	 asrs r3,r3,#8
 811 0026 87F82330 	 strb r3,[r7,#35]
 472:../SSC/Src/objdef.c **** 
 473:../SSC/Src/objdef.c ****     if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
 812              	 .loc 1 473 0
 813 002a 7B7B     	 ldrb r3,[r7,#13]
 814 002c 002B     	 cmp r3,#0
 815 002e 03D0     	 beq .L48
 816              	 .loc 1 473 0 is_stmt 0 discriminator 1
 817 0030 97F82330 	 ldrb r3,[r7,#35]
 818 0034 072B     	 cmp r3,#7
 819 0036 0FD1     	 bne .L49
 820              	.L48:
 474:../SSC/Src/objdef.c ****     {
 475:../SSC/Src/objdef.c ****         // Get object description length
 476:../SSC/Src/objdef.c ****         strSize = OBJSTRLEN( (OBJCONST CHAR OBJMEM *) pDesc );
 821              	 .loc 1 476 0 is_stmt 1
 822 0038 786A     	 ldr r0,[r7,#36]
 823 003a FFF7FEFF 	 bl strlen
 824 003e 0346     	 mov r3,r0
 825 0040 FB85     	 strh r3,[r7,#46]
 477:../SSC/Src/objdef.c **** 
 478:../SSC/Src/objdef.c ****         // If there is a pointer given, copy data:
 479:../SSC/Src/objdef.c ****         if ( pData )
 826              	 .loc 1 479 0
 827 0042 7B68     	 ldr r3,[r7,#4]
 828 0044 002B     	 cmp r3,#0
 829 0046 06D0     	 beq .L50
 480:../SSC/Src/objdef.c ****         {
 481:../SSC/Src/objdef.c ****             OBJTOMBXSTRCPY( pData, pDesc, strSize );
 830              	 .loc 1 481 0
 831 0048 FB8D     	 ldrh r3,[r7,#46]
 832 004a 7868     	 ldr r0,[r7,#4]
 833 004c 796A     	 ldr r1,[r7,#36]
 834 004e 1A46     	 mov r2,r3
 835 0050 FFF7FEFF 	 bl memcpy
 479:../SSC/Src/objdef.c ****         {
 836              	 .loc 1 479 0
 837 0054 5FE0     	 b .L51
 838              	.L50:
 839 0056 5EE0     	 b .L51
 840              	.L49:
 482:../SSC/Src/objdef.c ****         }
 483:../SSC/Src/objdef.c ****     }
 484:../SSC/Src/objdef.c ****     else
 485:../SSC/Src/objdef.c ****     {
 486:../SSC/Src/objdef.c ****         if ( objCode == OBJCODE_REC )
 841              	 .loc 1 486 0
 842 0058 97F82330 	 ldrb r3,[r7,#35]
 843 005c 092B     	 cmp r3,#9
 844 005e 3CD1     	 bne .L52
 845              	.LBB7:
 487:../SSC/Src/objdef.c ****         {
 488:../SSC/Src/objdef.c ****             {
 489:../SSC/Src/objdef.c ****             // get pointer to description of subindex 1 :
 490:../SSC/Src/objdef.c ****             // 16bit variable to avoid overflow if subindex 0xFF is read
 491:../SSC/Src/objdef.c ****             UINT16 i = 1;
 846              	 .loc 1 491 0
 847 0060 0123     	 movs r3,#1
 848 0062 BB85     	 strh r3,[r7,#44]
 492:../SSC/Src/objdef.c ****             UINT16 tmpSubindex = subindex;
 849              	 .loc 1 492 0
 850 0064 7B7B     	 ldrb r3,[r7,#13]
 851 0066 3B84     	 strh r3,[r7,#32]
 852              	.LBB8:
 493:../SSC/Src/objdef.c **** 
 494:../SSC/Src/objdef.c ****             {
 495:../SSC/Src/objdef.c **** 
 496:../SSC/Src/objdef.c ****             OBJCONST UCHAR OBJMEM * pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pDesc );
 853              	 .loc 1 496 0
 854 0068 786A     	 ldr r0,[r7,#36]
 855 006a FFF7FEFF 	 bl strlen
 856 006e 0346     	 mov r3,r0
 857 0070 0133     	 adds r3,r3,#1
 858 0072 7A6A     	 ldr r2,[r7,#36]
 859 0074 1344     	 add r3,r3,r2
 860 0076 BB62     	 str r3,[r7,#40]
 497:../SSC/Src/objdef.c ****             while (( i <= tmpSubindex )
 861              	 .loc 1 497 0
 862 0078 23E0     	 b .L53
 863              	.L57:
 498:../SSC/Src/objdef.c ****                 &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE ))
 499:../SSC/Src/objdef.c ****             {
 500:../SSC/Src/objdef.c ****                 if ( i == tmpSubindex )
 864              	 .loc 1 500 0
 865 007a BA8D     	 ldrh r2,[r7,#44]
 866 007c 3B8C     	 ldrh r3,[r7,#32]
 867 007e 9A42     	 cmp r2,r3
 868 0080 14D1     	 bne .L54
 501:../SSC/Src/objdef.c ****                 {
 502:../SSC/Src/objdef.c ****                     strSize = OBJSTRLEN( (OBJCONST CHAR OBJMEM *) pSubDesc );
 869              	 .loc 1 502 0
 870 0082 B86A     	 ldr r0,[r7,#40]
 871 0084 FFF7FEFF 	 bl strlen
 872 0088 0346     	 mov r3,r0
 873 008a FB85     	 strh r3,[r7,#46]
 503:../SSC/Src/objdef.c ****                     if ( pData && strSize )
 874              	 .loc 1 503 0
 875 008c 7B68     	 ldr r3,[r7,#4]
 876 008e 002B     	 cmp r3,#0
 877 0090 09D0     	 beq .L55
 878              	 .loc 1 503 0 is_stmt 0 discriminator 1
 879 0092 FB8D     	 ldrh r3,[r7,#46]
 880 0094 002B     	 cmp r3,#0
 881 0096 06D0     	 beq .L55
 504:../SSC/Src/objdef.c ****                         OBJTOMBXSTRCPY( pData, pSubDesc, strSize );
 882              	 .loc 1 504 0 is_stmt 1
 883 0098 FB8D     	 ldrh r3,[r7,#46]
 884 009a 7868     	 ldr r0,[r7,#4]
 885 009c B96A     	 ldr r1,[r7,#40]
 886 009e 1A46     	 mov r2,r3
 887 00a0 FFF7FEFF 	 bl memcpy
 505:../SSC/Src/objdef.c **** /* ECATCHANGE_START(V5.11) SDO6*/
 506:../SSC/Src/objdef.c ****                     else
 507:../SSC/Src/objdef.c ****                         strSize = 0;
 508:../SSC/Src/objdef.c **** /* ECATCHANGE_END(V5.11) SDO6*/
 509:../SSC/Src/objdef.c **** 
 510:../SSC/Src/objdef.c ****                     break;
 888              	 .loc 1 510 0
 889 00a4 19E0     	 b .L52
 890              	.L55:
 507:../SSC/Src/objdef.c **** /* ECATCHANGE_END(V5.11) SDO6*/
 891              	 .loc 1 507 0
 892 00a6 0023     	 movs r3,#0
 893 00a8 FB85     	 strh r3,[r7,#46]
 894              	 .loc 1 510 0
 895 00aa 16E0     	 b .L52
 896              	.L54:
 511:../SSC/Src/objdef.c ****                 }
 512:../SSC/Src/objdef.c ****                 else
 513:../SSC/Src/objdef.c ****                 {
 514:../SSC/Src/objdef.c ****                     i++;
 897              	 .loc 1 514 0
 898 00ac BB8D     	 ldrh r3,[r7,#44]
 899 00ae 0133     	 adds r3,r3,#1
 900 00b0 BB85     	 strh r3,[r7,#44]
 515:../SSC/Src/objdef.c ****                     pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pSubDesc );
 901              	 .loc 1 515 0
 902 00b2 B86A     	 ldr r0,[r7,#40]
 903 00b4 FFF7FEFF 	 bl strlen
 904 00b8 0346     	 mov r3,r0
 905 00ba 0133     	 adds r3,r3,#1
 906 00bc BA6A     	 ldr r2,[r7,#40]
 907 00be 1344     	 add r3,r3,r2
 908 00c0 BB62     	 str r3,[r7,#40]
 909              	.L53:
 497:../SSC/Src/objdef.c ****                 &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE ))
 910              	 .loc 1 497 0
 911 00c2 BA8D     	 ldrh r2,[r7,#44]
 912 00c4 3B8C     	 ldrh r3,[r7,#32]
 913 00c6 9A42     	 cmp r2,r3
 914 00c8 07D8     	 bhi .L52
 498:../SSC/Src/objdef.c ****             {
 915              	 .loc 1 498 0
 916 00ca BB6A     	 ldr r3,[r7,#40]
 917 00cc 1B78     	 ldrb r3,[r3]
 918 00ce FF2B     	 cmp r3,#255
 919 00d0 03D0     	 beq .L52
 498:../SSC/Src/objdef.c ****             {
 920              	 .loc 1 498 0 is_stmt 0 discriminator 1
 921 00d2 BB6A     	 ldr r3,[r7,#40]
 922 00d4 1B78     	 ldrb r3,[r3]
 923 00d6 FE2B     	 cmp r3,#254
 924 00d8 CFD1     	 bne .L57
 925              	.L52:
 926              	.LBE8:
 927              	.LBE7:
 516:../SSC/Src/objdef.c ****                 }
 517:../SSC/Src/objdef.c ****             }
 518:../SSC/Src/objdef.c ****             }
 519:../SSC/Src/objdef.c ****             }
 520:../SSC/Src/objdef.c ****         }
 521:../SSC/Src/objdef.c **** 
 522:../SSC/Src/objdef.c ****         if ( strSize == 0 )
 928              	 .loc 1 522 0 is_stmt 1
 929 00da FB8D     	 ldrh r3,[r7,#46]
 930 00dc 002B     	 cmp r3,#0
 931 00de 1AD1     	 bne .L51
 523:../SSC/Src/objdef.c ****         {
 524:../SSC/Src/objdef.c ****             // no string found for subindex x -> name is Subindex x
 525:../SSC/Src/objdef.c ****             strSize =    12;
 932              	 .loc 1 525 0
 933 00e0 0C23     	 movs r3,#12
 934 00e2 FB85     	 strh r3,[r7,#46]
 526:../SSC/Src/objdef.c **** 
 527:../SSC/Src/objdef.c ****             if ( pData )
 935              	 .loc 1 527 0
 936 00e4 7B68     	 ldr r3,[r7,#4]
 937 00e6 002B     	 cmp r3,#0
 938 00e8 15D0     	 beq .L51
 939              	.LBB9:
 528:../SSC/Src/objdef.c ****             {
 529:../SSC/Src/objdef.c ****                 UCHAR OBJMEM         TmpDescr[13];
 530:../SSC/Src/objdef.c ****                 OBJSTRCPY(TmpDescr,aSubindexDesc,SIZEOF(TmpDescr));
 940              	 .loc 1 530 0
 941 00ea 0D4B     	 ldr r3,.L59
 942 00ec 07F11004 	 add r4,r7,#16
 943 00f0 0FCB     	 ldmia r3,{r0,r1,r2,r3}
 944 00f2 07C4     	 stmia r4!,{r0,r1,r2}
 945 00f4 2370     	 strb r3,[r4]
 531:../SSC/Src/objdef.c ****                 
 532:../SSC/Src/objdef.c ****                 OBJ_CopyNumberToString( &TmpDescr[9], subindex );
 946              	 .loc 1 532 0
 947 00f6 07F11003 	 add r3,r7,#16
 948 00fa 03F10902 	 add r2,r3,#9
 949 00fe 7B7B     	 ldrb r3,[r7,#13]
 950 0100 1046     	 mov r0,r2
 951 0102 1946     	 mov r1,r3
 952 0104 FFF7FEFF 	 bl OBJ_CopyNumberToString
 533:../SSC/Src/objdef.c ****                 MBXSTRCPY( pData, TmpDescr, SIZEOF(TmpDescr) );
 953              	 .loc 1 533 0
 954 0108 07F11003 	 add r3,r7,#16
 955 010c 7868     	 ldr r0,[r7,#4]
 956 010e 1946     	 mov r1,r3
 957 0110 0D22     	 movs r2,#13
 958 0112 FFF7FEFF 	 bl memcpy
 959              	.L51:
 960              	.LBE9:
 534:../SSC/Src/objdef.c ****             }
 535:../SSC/Src/objdef.c ****         }
 536:../SSC/Src/objdef.c ****     }
 537:../SSC/Src/objdef.c **** 
 538:../SSC/Src/objdef.c ****     return strSize;
 961              	 .loc 1 538 0
 962 0116 FB8D     	 ldrh r3,[r7,#46]
 539:../SSC/Src/objdef.c **** }
 963              	 .loc 1 539 0
 964 0118 1846     	 mov r0,r3
 965 011a 3437     	 adds r7,r7,#52
 966              	.LCFI30:
 967              	 .cfi_def_cfa_offset 12
 968 011c BD46     	 mov sp,r7
 969              	.LCFI31:
 970              	 .cfi_def_cfa_register 13
 971              	 
 972 011e 90BD     	 pop {r4,r7,pc}
 973              	.L60:
 974              	 .align 2
 975              	.L59:
 976 0120 00000000 	 .word aSubindexDesc
 977              	 .cfi_endproc
 978              	.LFE177:
 980              	 .section .text.OBJ_GetEntryDesc,"ax",%progbits
 981              	 .align 2
 982              	 .global OBJ_GetEntryDesc
 983              	 .thumb
 984              	 .thumb_func
 986              	OBJ_GetEntryDesc:
 987              	.LFB178:
 540:../SSC/Src/objdef.c **** 
 541:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 542:../SSC/Src/objdef.c **** /**
 543:../SSC/Src/objdef.c ****  \param     pObjEntry            handle to the dictionary object returned by
 544:../SSC/Src/objdef.c ****                                      OBJ_GetObjectHandle which was called before
 545:../SSC/Src/objdef.c ****  \param     Subindex                subindex of the requested object.
 546:../SSC/Src/objdef.c **** 
 547:../SSC/Src/objdef.c ****  \return    Pointer to the EntryDesc of the Subindex
 548:../SSC/Src/objdef.c **** 
 549:../SSC/Src/objdef.c ****  \brief    The function returns the Entry-Desc of a subindex to allow the application
 550:../SSC/Src/objdef.c ****          to define the object dictionary independent of the sdoserv-files
 551:../SSC/Src/objdef.c **** 
 552:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 553:../SSC/Src/objdef.c **** 
 554:../SSC/Src/objdef.c **** OBJCONST TSDOINFOENTRYDESC OBJMEM * OBJ_GetEntryDesc(OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 Sub
 555:../SSC/Src/objdef.c **** {
 988              	 .loc 1 555 0
 989              	 .cfi_startproc
 990              	 
 991              	 
 992              	 
 993 0000 80B4     	 push {r7}
 994              	.LCFI32:
 995              	 .cfi_def_cfa_offset 4
 996              	 .cfi_offset 7,-4
 997 0002 85B0     	 sub sp,sp,#20
 998              	.LCFI33:
 999              	 .cfi_def_cfa_offset 24
 1000 0004 00AF     	 add r7,sp,#0
 1001              	.LCFI34:
 1002              	 .cfi_def_cfa_register 7
 1003 0006 7860     	 str r0,[r7,#4]
 1004 0008 0B46     	 mov r3,r1
 1005 000a FB70     	 strb r3,[r7,#3]
 556:../SSC/Src/objdef.c ****     OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
 557:../SSC/Src/objdef.c ****     UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 1006              	 .loc 1 557 0
 1007 000c 7B68     	 ldr r3,[r7,#4]
 1008 000e 9B89     	 ldrh r3,[r3,#12]
 1009 0010 03F47063 	 and r3,r3,#3840
 1010 0014 1B12     	 asrs r3,r3,#8
 1011 0016 FB72     	 strb r3,[r7,#11]
 558:../SSC/Src/objdef.c **** 
 559:../SSC/Src/objdef.c ****     if ((objCode == OBJCODE_ARR)
 1012              	 .loc 1 559 0
 1013 0018 FB7A     	 ldrb r3,[r7,#11]
 1014 001a 082B     	 cmp r3,#8
 1015 001c 0BD1     	 bne .L62
 560:../SSC/Src/objdef.c ****         )
 561:../SSC/Src/objdef.c ****     {
 562:../SSC/Src/objdef.c ****         /* object is an array */
 563:../SSC/Src/objdef.c ****         if ( Subindex == 0 )
 1016              	 .loc 1 563 0
 1017 001e FB78     	 ldrb r3,[r7,#3]
 1018 0020 002B     	 cmp r3,#0
 1019 0022 03D1     	 bne .L63
 564:../SSC/Src/objdef.c ****             /* subindex 0 has a description */
 565:../SSC/Src/objdef.c ****             pEntry = &pObjEntry->pEntryDesc[0];
 1020              	 .loc 1 565 0
 1021 0024 7B68     	 ldr r3,[r7,#4]
 1022 0026 1B69     	 ldr r3,[r3,#16]
 1023 0028 FB60     	 str r3,[r7,#12]
 1024 002a 0DE0     	 b .L65
 1025              	.L63:
 566:../SSC/Src/objdef.c ****         else
 567:../SSC/Src/objdef.c ****             /* and all other elements have the same description */
 568:../SSC/Src/objdef.c ****             pEntry = &pObjEntry->pEntryDesc[1];
 1026              	 .loc 1 568 0
 1027 002c 7B68     	 ldr r3,[r7,#4]
 1028 002e 1B69     	 ldr r3,[r3,#16]
 1029 0030 0633     	 adds r3,r3,#6
 1030 0032 FB60     	 str r3,[r7,#12]
 1031 0034 08E0     	 b .L65
 1032              	.L62:
 569:../SSC/Src/objdef.c ****     }
 570:../SSC/Src/objdef.c ****     else
 571:../SSC/Src/objdef.c ****     {
 572:../SSC/Src/objdef.c ****         {
 573:../SSC/Src/objdef.c ****             /* object is a variable or a record return the corresponding entry */
 574:../SSC/Src/objdef.c ****             pEntry = &pObjEntry->pEntryDesc[Subindex];
 1033              	 .loc 1 574 0
 1034 0036 7B68     	 ldr r3,[r7,#4]
 1035 0038 1969     	 ldr r1,[r3,#16]
 1036 003a FA78     	 ldrb r2,[r7,#3]
 1037 003c 1346     	 mov r3,r2
 1038 003e 5B00     	 lsls r3,r3,#1
 1039 0040 1344     	 add r3,r3,r2
 1040 0042 5B00     	 lsls r3,r3,#1
 1041 0044 0B44     	 add r3,r3,r1
 1042 0046 FB60     	 str r3,[r7,#12]
 1043              	.L65:
 575:../SSC/Src/objdef.c ****         }
 576:../SSC/Src/objdef.c ****     }
 577:../SSC/Src/objdef.c **** 
 578:../SSC/Src/objdef.c ****     return pEntry;
 1044              	 .loc 1 578 0
 1045 0048 FB68     	 ldr r3,[r7,#12]
 579:../SSC/Src/objdef.c **** }
 1046              	 .loc 1 579 0
 1047 004a 1846     	 mov r0,r3
 1048 004c 1437     	 adds r7,r7,#20
 1049              	.LCFI35:
 1050              	 .cfi_def_cfa_offset 4
 1051 004e BD46     	 mov sp,r7
 1052              	.LCFI36:
 1053              	 .cfi_def_cfa_register 13
 1054              	 
 1055 0050 5DF8047B 	 ldr r7,[sp],#4
 1056              	.LCFI37:
 1057              	 .cfi_restore 7
 1058              	 .cfi_def_cfa_offset 0
 1059 0054 7047     	 bx lr
 1060              	 .cfi_endproc
 1061              	.LFE178:
 1063 0056 00BF     	 .section .text.OBJ_GetObjDesc,"ax",%progbits
 1064              	 .align 2
 1065              	 .global OBJ_GetObjDesc
 1066              	 .thumb
 1067              	 .thumb_func
 1069              	OBJ_GetObjDesc:
 1070              	.LFB179:
 580:../SSC/Src/objdef.c **** 
 581:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 582:../SSC/Src/objdef.c **** /**
 583:../SSC/Src/objdef.c ****  \param     pObjEntry            handle to the dictionary object returned by
 584:../SSC/Src/objdef.c ****                                      OBJ_GetObjectHandle which was called before
 585:../SSC/Src/objdef.c **** 
 586:../SSC/Src/objdef.c ****  \return    Pointer to the ObjDesc of the Object
 587:../SSC/Src/objdef.c **** 
 588:../SSC/Src/objdef.c ****  \brief    The function returns the Obj-Desc of an object to allow the application
 589:../SSC/Src/objdef.c ****          to define the object dictionary independent of the sdoserv-files
 590:../SSC/Src/objdef.c **** 
 591:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 592:../SSC/Src/objdef.c **** 
 593:../SSC/Src/objdef.c **** OBJCONST TSDOINFOOBJDESC OBJMEM * OBJ_GetObjDesc(OBJCONST TOBJECT OBJMEM * pObjEntry)
 594:../SSC/Src/objdef.c **** {
 1071              	 .loc 1 594 0
 1072              	 .cfi_startproc
 1073              	 
 1074              	 
 1075              	 
 1076 0000 80B4     	 push {r7}
 1077              	.LCFI38:
 1078              	 .cfi_def_cfa_offset 4
 1079              	 .cfi_offset 7,-4
 1080 0002 83B0     	 sub sp,sp,#12
 1081              	.LCFI39:
 1082              	 .cfi_def_cfa_offset 16
 1083 0004 00AF     	 add r7,sp,#0
 1084              	.LCFI40:
 1085              	 .cfi_def_cfa_register 7
 1086 0006 7860     	 str r0,[r7,#4]
 595:../SSC/Src/objdef.c ****     return &pObjEntry->ObjDesc;
 1087              	 .loc 1 595 0
 1088 0008 7B68     	 ldr r3,[r7,#4]
 1089 000a 0A33     	 adds r3,r3,#10
 596:../SSC/Src/objdef.c **** }
 1090              	 .loc 1 596 0
 1091 000c 1846     	 mov r0,r3
 1092 000e 0C37     	 adds r7,r7,#12
 1093              	.LCFI41:
 1094              	 .cfi_def_cfa_offset 4
 1095 0010 BD46     	 mov sp,r7
 1096              	.LCFI42:
 1097              	 .cfi_def_cfa_register 13
 1098              	 
 1099 0012 5DF8047B 	 ldr r7,[sp],#4
 1100              	.LCFI43:
 1101              	 .cfi_restore 7
 1102              	 .cfi_def_cfa_offset 0
 1103 0016 7047     	 bx lr
 1104              	 .cfi_endproc
 1105              	.LFE179:
 1107              	 .section .text.OBJ_GetEntryOffset,"ax",%progbits
 1108              	 .align 2
 1109              	 .global OBJ_GetEntryOffset
 1110              	 .thumb
 1111              	 .thumb_func
 1113              	OBJ_GetEntryOffset:
 1114              	.LFB180:
 597:../SSC/Src/objdef.c **** 
 598:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 599:../SSC/Src/objdef.c **** /**
 600:../SSC/Src/objdef.c ****  \param     subindex                subindex of the entry
 601:../SSC/Src/objdef.c ****  \param     pObjEntry            handle to the dictionary object returned by
 602:../SSC/Src/objdef.c ****                                      OBJ_GetObjectHandle which was called before
 603:../SSC/Src/objdef.c **** 
 604:../SSC/Src/objdef.c ****  \return    bit offset of the entry in the variable
 605:../SSC/Src/objdef.c **** 
 606:../SSC/Src/objdef.c ****  \brief    This function calculates the bit offset of the entry in the object's variable
 607:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 608:../SSC/Src/objdef.c **** 
 609:../SSC/Src/objdef.c **** UINT16 OBJ_GetEntryOffset(UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry)
 610:../SSC/Src/objdef.c **** {
 1115              	 .loc 1 610 0
 1116              	 .cfi_startproc
 1117              	 
 1118              	 
 1119              	 
 1120 0000 80B4     	 push {r7}
 1121              	.LCFI44:
 1122              	 .cfi_def_cfa_offset 4
 1123              	 .cfi_offset 7,-4
 1124 0002 87B0     	 sub sp,sp,#28
 1125              	.LCFI45:
 1126              	 .cfi_def_cfa_offset 32
 1127 0004 00AF     	 add r7,sp,#0
 1128              	.LCFI46:
 1129              	 .cfi_def_cfa_register 7
 1130 0006 0346     	 mov r3,r0
 1131 0008 3960     	 str r1,[r7]
 1132 000a FB71     	 strb r3,[r7,#7]
 611:../SSC/Src/objdef.c ****     UINT16 i;
 612:../SSC/Src/objdef.c ****     /* bitOffset will be initialized with the bit offset of subindex 1 */
 613:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) OBJ1*/
 614:../SSC/Src/objdef.c ****     UINT16 bitOffset = 0;
 1133              	 .loc 1 614 0
 1134 000c 0023     	 movs r3,#0
 1135 000e BB82     	 strh r3,[r7,#20]
 615:../SSC/Src/objdef.c ****     UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 1136              	 .loc 1 615 0
 1137 0010 3B68     	 ldr r3,[r7]
 1138 0012 9B89     	 ldrh r3,[r3,#12]
 1139 0014 03F47063 	 and r3,r3,#3840
 1140 0018 1B12     	 asrs r3,r3,#8
 1141 001a FB73     	 strb r3,[r7,#15]
 616:../SSC/Src/objdef.c ****     OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
 617:../SSC/Src/objdef.c **** 
 618:../SSC/Src/objdef.c ****     if(subindex > 0)
 1142              	 .loc 1 618 0
 1143 001c FB79     	 ldrb r3,[r7,#7]
 1144 001e 002B     	 cmp r3,#0
 1145 0020 02D0     	 beq .L70
 619:../SSC/Src/objdef.c ****     {
 620:../SSC/Src/objdef.c ****         /*subindex 1 has an offset of 16Bit (even if Si0 is only an UINT8) */
 621:../SSC/Src/objdef.c ****         bitOffset +=16;
 1146              	 .loc 1 621 0
 1147 0022 BB8A     	 ldrh r3,[r7,#20]
 1148 0024 1033     	 adds r3,r3,#16
 1149 0026 BB82     	 strh r3,[r7,#20]
 1150              	.L70:
 622:../SSC/Src/objdef.c ****     }
 623:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) OBJ1*/
 624:../SSC/Src/objdef.c **** 
 625:../SSC/Src/objdef.c ****     if (objCode == OBJCODE_VAR)
 1151              	 .loc 1 625 0
 1152 0028 FB7B     	 ldrb r3,[r7,#15]
 1153 002a 072B     	 cmp r3,#7
 1154 002c 01D1     	 bne .L71
 626:../SSC/Src/objdef.c ****         return 0;
 1155              	 .loc 1 626 0
 1156 002e 0023     	 movs r3,#0
 1157 0030 91E0     	 b .L72
 1158              	.L71:
 627:../SSC/Src/objdef.c **** 
 628:../SSC/Src/objdef.c ****     for (i = 1; i <= subindex; i++)
 1159              	 .loc 1 628 0
 1160 0032 0123     	 movs r3,#1
 1161 0034 FB82     	 strh r3,[r7,#22]
 1162 0036 87E0     	 b .L73
 1163              	.L90:
 629:../SSC/Src/objdef.c ****     {
 630:../SSC/Src/objdef.c ****         /* get the entry description */
 631:../SSC/Src/objdef.c ****         if ((objCode == OBJCODE_ARR)
 1164              	 .loc 1 631 0
 1165 0038 FB7B     	 ldrb r3,[r7,#15]
 1166 003a 082B     	 cmp r3,#8
 1167 003c 04D1     	 bne .L74
 632:../SSC/Src/objdef.c ****            )
 633:../SSC/Src/objdef.c ****             pEntry = &pObjEntry->pEntryDesc[1];
 1168              	 .loc 1 633 0
 1169 003e 3B68     	 ldr r3,[r7]
 1170 0040 1B69     	 ldr r3,[r3,#16]
 1171 0042 0633     	 adds r3,r3,#6
 1172 0044 3B61     	 str r3,[r7,#16]
 1173 0046 08E0     	 b .L75
 1174              	.L74:
 634:../SSC/Src/objdef.c ****         else
 635:../SSC/Src/objdef.c ****         {
 636:../SSC/Src/objdef.c ****             pEntry = &pObjEntry->pEntryDesc[i];
 1175              	 .loc 1 636 0
 1176 0048 3B68     	 ldr r3,[r7]
 1177 004a 1969     	 ldr r1,[r3,#16]
 1178 004c FA8A     	 ldrh r2,[r7,#22]
 1179 004e 1346     	 mov r3,r2
 1180 0050 5B00     	 lsls r3,r3,#1
 1181 0052 1344     	 add r3,r3,r2
 1182 0054 5B00     	 lsls r3,r3,#1
 1183 0056 0B44     	 add r3,r3,r1
 1184 0058 3B61     	 str r3,[r7,#16]
 1185              	.L75:
 637:../SSC/Src/objdef.c ****         }
 638:../SSC/Src/objdef.c **** 
 639:../SSC/Src/objdef.c ****         switch (pEntry->DataType)
 1186              	 .loc 1 639 0
 1187 005a 3B69     	 ldr r3,[r7,#16]
 1188 005c 1B88     	 ldrh r3,[r3]
 1189 005e 1F2B     	 cmp r3,#31
 1190 0060 23D0     	 beq .L77
 1191 0062 1F2B     	 cmp r3,#31
 1192 0064 0DDC     	 bgt .L78
 1193 0066 062B     	 cmp r3,#6
 1194 0068 1FD0     	 beq .L77
 1195 006a 062B     	 cmp r3,#6
 1196 006c 04DC     	 bgt .L79
 1197 006e 032B     	 cmp r3,#3
 1198 0070 1BD0     	 beq .L77
 1199 0072 042B     	 cmp r3,#4
 1200 0074 37D0     	 beq .L80
 1201 0076 58E0     	 b .L76
 1202              	.L79:
 1203 0078 082B     	 cmp r3,#8
 1204 007a 34DD     	 ble .L80
 1205 007c 0B2B     	 cmp r3,#11
 1206 007e 14D0     	 beq .L77
 1207 0080 53E0     	 b .L76
 1208              	.L78:
 1209 0082 2F2B     	 cmp r3,#47
 1210 0084 2FD0     	 beq .L80
 1211 0086 2F2B     	 cmp r3,#47
 1212 0088 04DC     	 bgt .L81
 1213 008a 202B     	 cmp r3,#32
 1214 008c 2BD0     	 beq .L80
 1215 008e 2E2B     	 cmp r3,#46
 1216 0090 0BD0     	 beq .L77
 1217 0092 4AE0     	 b .L76
 1218              	.L81:
 1219 0094 B3F5187F 	 cmp r3,#608
 1220 0098 07D0     	 beq .L77
 1221 009a B3F5187F 	 cmp r3,#608
 1222 009e 44DB     	 blt .L76
 1223 00a0 A3F26223 	 subw r3,r3,#610
 1224 00a4 012B     	 cmp r3,#1
 1225 00a6 40D8     	 bhi .L76
 1226 00a8 1DE0     	 b .L80
 1227              	.L77:
 640:../SSC/Src/objdef.c ****         {
 641:../SSC/Src/objdef.c ****         case    DEFTYPE_INTEGER16:
 642:../SSC/Src/objdef.c ****         case    DEFTYPE_UNSIGNED16:
 643:../SSC/Src/objdef.c ****         case    DEFTYPE_BITARR16:
 644:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO9*/
 645:../SSC/Src/objdef.c ****         case    DEFTYPE_WORD:
 646:../SSC/Src/objdef.c ****         case    DEFTYPE_UNICODE_STRING:
 647:../SSC/Src/objdef.c ****         case    DEFTYPE_ARRAY_OF_INT :
 648:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO9*/
 649:../SSC/Src/objdef.c **** 
 650:../SSC/Src/objdef.c **** #if OBJ_WORD_ALIGN    || OBJ_DWORD_ALIGN
 651:../SSC/Src/objdef.c ****             /* the 16-bit variables in the structure are word-aligned,
 652:../SSC/Src/objdef.c ****                align the actual bitOffset to a word */
 653:../SSC/Src/objdef.c ****             bitOffset = (bitOffset+15) & 0xFFF0;
 1228              	 .loc 1 653 0
 1229 00aa BB8A     	 ldrh r3,[r7,#20]
 1230 00ac 0F33     	 adds r3,r3,#15
 1231 00ae 9BB2     	 uxth r3,r3
 1232 00b0 23F00F03 	 bic r3,r3,#15
 1233 00b4 BB82     	 strh r3,[r7,#20]
 654:../SSC/Src/objdef.c **** #endif
 655:../SSC/Src/objdef.c **** 
 656:../SSC/Src/objdef.c **** 
 657:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO9*/
 658:../SSC/Src/objdef.c ****             if (i < subindex)
 1234              	 .loc 1 658 0
 1235 00b6 FB79     	 ldrb r3,[r7,#7]
 1236 00b8 9BB2     	 uxth r3,r3
 1237 00ba FA8A     	 ldrh r2,[r7,#22]
 1238 00bc 9A42     	 cmp r2,r3
 1239 00be 11D2     	 bcs .L82
 659:../SSC/Src/objdef.c ****             {
 660:../SSC/Src/objdef.c ****                 if((pEntry->DataType == DEFTYPE_UNICODE_STRING)
 1240              	 .loc 1 660 0
 1241 00c0 3B69     	 ldr r3,[r7,#16]
 1242 00c2 1B88     	 ldrh r3,[r3]
 1243 00c4 0B2B     	 cmp r3,#11
 1244 00c6 04D0     	 beq .L83
 661:../SSC/Src/objdef.c ****                     ||(pEntry->DataType == DEFTYPE_ARRAY_OF_INT))
 1245              	 .loc 1 661 0
 1246 00c8 3B69     	 ldr r3,[r7,#16]
 1247 00ca 1B88     	 ldrh r3,[r3]
 1248 00cc B3F5187F 	 cmp r3,#608
 1249 00d0 04D1     	 bne .L84
 1250              	.L83:
 662:../SSC/Src/objdef.c ****                 {
 663:../SSC/Src/objdef.c ****                     bitOffset += pEntry->BitLength;
 1251              	 .loc 1 663 0
 1252 00d2 3B69     	 ldr r3,[r7,#16]
 1253 00d4 5A88     	 ldrh r2,[r3,#2]
 1254 00d6 BB8A     	 ldrh r3,[r7,#20]
 1255 00d8 1344     	 add r3,r3,r2
 1256 00da BB82     	 strh r3,[r7,#20]
 1257              	.L84:
 664:../SSC/Src/objdef.c ****                 }
 665:../SSC/Src/objdef.c **** 
 666:../SSC/Src/objdef.c ****                 bitOffset += 16;
 1258              	 .loc 1 666 0
 1259 00dc BB8A     	 ldrh r3,[r7,#20]
 1260 00de 1033     	 adds r3,r3,#16
 1261 00e0 BB82     	 strh r3,[r7,#20]
 667:../SSC/Src/objdef.c ****             }
 668:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO9*/
 669:../SSC/Src/objdef.c ****             break;
 1262              	 .loc 1 669 0
 1263 00e2 2EE0     	 b .L85
 1264              	.L82:
 1265 00e4 2DE0     	 b .L85
 1266              	.L80:
 670:../SSC/Src/objdef.c ****         case    DEFTYPE_UNSIGNED32:
 671:../SSC/Src/objdef.c ****         case    DEFTYPE_INTEGER32:
 672:../SSC/Src/objdef.c ****         case    DEFTYPE_REAL32:
 673:../SSC/Src/objdef.c ****         case    DEFTYPE_BITARR32:
 674:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO9*/
 675:../SSC/Src/objdef.c ****         case    DEFTYPE_DWORD:
 676:../SSC/Src/objdef.c ****         case    DEFTYPE_ARRAY_OF_DINT :
 677:../SSC/Src/objdef.c ****         case    DEFTYPE_ARRAY_OF_UDINT:
 678:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO9*/
 679:../SSC/Src/objdef.c **** #if OBJ_DWORD_ALIGN
 680:../SSC/Src/objdef.c ****             /* the 32-bit variables in the structure are dword-aligned,
 681:../SSC/Src/objdef.c ****                align the actual bitOffset to a dword */
 682:../SSC/Src/objdef.c ****             bitOffset = (bitOffset+31) & 0xFFE0;
 1267              	 .loc 1 682 0
 1268 00e6 BB8A     	 ldrh r3,[r7,#20]
 1269 00e8 1F33     	 adds r3,r3,#31
 1270 00ea 9BB2     	 uxth r3,r3
 1271 00ec 23F01F03 	 bic r3,r3,#31
 1272 00f0 BB82     	 strh r3,[r7,#20]
 683:../SSC/Src/objdef.c **** #elif OBJ_WORD_ALIGN
 684:../SSC/Src/objdef.c ****             /* the 32-bit variables in the structure are word-aligned,
 685:../SSC/Src/objdef.c ****                align the actual bitOffset to a word */
 686:../SSC/Src/objdef.c ****             bitOffset = (bitOffset+15) & 0xFFF0;
 687:../SSC/Src/objdef.c **** #endif
 688:../SSC/Src/objdef.c **** 
 689:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO9*/
 690:../SSC/Src/objdef.c ****             if (i < subindex)
 1273              	 .loc 1 690 0
 1274 00f2 FB79     	 ldrb r3,[r7,#7]
 1275 00f4 9BB2     	 uxth r3,r3
 1276 00f6 FA8A     	 ldrh r2,[r7,#22]
 1277 00f8 9A42     	 cmp r2,r3
 1278 00fa 15D2     	 bcs .L86
 691:../SSC/Src/objdef.c ****             {
 692:../SSC/Src/objdef.c ****                 if((pEntry->DataType == DEFTYPE_ARRAY_OF_DINT)
 1279              	 .loc 1 692 0
 1280 00fc 3B69     	 ldr r3,[r7,#16]
 1281 00fe 1B88     	 ldrh r3,[r3]
 1282 0100 40F26222 	 movw r2,#610
 1283 0104 9342     	 cmp r3,r2
 1284 0106 05D0     	 beq .L87
 693:../SSC/Src/objdef.c ****                     ||(pEntry->DataType == DEFTYPE_ARRAY_OF_UDINT))
 1285              	 .loc 1 693 0
 1286 0108 3B69     	 ldr r3,[r7,#16]
 1287 010a 1B88     	 ldrh r3,[r3]
 1288 010c 40F26322 	 movw r2,#611
 1289 0110 9342     	 cmp r3,r2
 1290 0112 05D1     	 bne .L88
 1291              	.L87:
 694:../SSC/Src/objdef.c ****                 {
 695:../SSC/Src/objdef.c ****                     bitOffset += pEntry->BitLength;
 1292              	 .loc 1 695 0
 1293 0114 3B69     	 ldr r3,[r7,#16]
 1294 0116 5A88     	 ldrh r2,[r3,#2]
 1295 0118 BB8A     	 ldrh r3,[r7,#20]
 1296 011a 1344     	 add r3,r3,r2
 1297 011c BB82     	 strh r3,[r7,#20]
 1298 011e 03E0     	 b .L86
 1299              	.L88:
 696:../SSC/Src/objdef.c ****                 }
 697:../SSC/Src/objdef.c ****                 else
 698:../SSC/Src/objdef.c ****                    bitOffset += 32;
 1300              	 .loc 1 698 0
 1301 0120 BB8A     	 ldrh r3,[r7,#20]
 1302 0122 2033     	 adds r3,r3,#32
 1303 0124 BB82     	 strh r3,[r7,#20]
 699:../SSC/Src/objdef.c ****             }
 700:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO9*/
 701:../SSC/Src/objdef.c ****             break;
 1304              	 .loc 1 701 0
 1305 0126 0CE0     	 b .L85
 1306              	.L86:
 1307 0128 0BE0     	 b .L85
 1308              	.L76:
 702:../SSC/Src/objdef.c ****         default:
 703:../SSC/Src/objdef.c ****             /* align the actual bitOffset to a byte */
 704:../SSC/Src/objdef.c ****             if (i < subindex)
 1309              	 .loc 1 704 0
 1310 012a FB79     	 ldrb r3,[r7,#7]
 1311 012c 9BB2     	 uxth r3,r3
 1312 012e FA8A     	 ldrh r2,[r7,#22]
 1313 0130 9A42     	 cmp r2,r3
 1314 0132 05D2     	 bcs .L89
 705:../SSC/Src/objdef.c ****                 bitOffset += pEntry->BitLength;
 1315              	 .loc 1 705 0
 1316 0134 3B69     	 ldr r3,[r7,#16]
 1317 0136 5A88     	 ldrh r2,[r3,#2]
 1318 0138 BB8A     	 ldrh r3,[r7,#20]
 1319 013a 1344     	 add r3,r3,r2
 1320 013c BB82     	 strh r3,[r7,#20]
 706:../SSC/Src/objdef.c ****             break;
 1321              	 .loc 1 706 0
 1322 013e FFE7     	 b .L91
 1323              	.L89:
 1324              	.L91:
 1325 0140 00BF     	 nop
 1326              	.L85:
 628:../SSC/Src/objdef.c ****     {
 1327              	 .loc 1 628 0 discriminator 2
 1328 0142 FB8A     	 ldrh r3,[r7,#22]
 1329 0144 0133     	 adds r3,r3,#1
 1330 0146 FB82     	 strh r3,[r7,#22]
 1331              	.L73:
 628:../SSC/Src/objdef.c ****     {
 1332              	 .loc 1 628 0 is_stmt 0 discriminator 1
 1333 0148 FB79     	 ldrb r3,[r7,#7]
 1334 014a 9BB2     	 uxth r3,r3
 1335 014c FA8A     	 ldrh r2,[r7,#22]
 1336 014e 9A42     	 cmp r2,r3
 1337 0150 7FF672AF 	 bls .L90
 707:../SSC/Src/objdef.c ****         }
 708:../SSC/Src/objdef.c ****     }
 709:../SSC/Src/objdef.c **** 
 710:../SSC/Src/objdef.c ****     return bitOffset;
 1338              	 .loc 1 710 0 is_stmt 1
 1339 0154 BB8A     	 ldrh r3,[r7,#20]
 1340              	.L72:
 711:../SSC/Src/objdef.c **** }
 1341              	 .loc 1 711 0
 1342 0156 1846     	 mov r0,r3
 1343 0158 1C37     	 adds r7,r7,#28
 1344              	.LCFI47:
 1345              	 .cfi_def_cfa_offset 4
 1346 015a BD46     	 mov sp,r7
 1347              	.LCFI48:
 1348              	 .cfi_def_cfa_register 13
 1349              	 
 1350 015c 5DF8047B 	 ldr r7,[sp],#4
 1351              	.LCFI49:
 1352              	 .cfi_restore 7
 1353              	 .cfi_def_cfa_offset 0
 1354 0160 7047     	 bx lr
 1355              	 .cfi_endproc
 1356              	.LFE180:
 1358 0162 00BF     	 .section .text.CheckSyncTypeValue,"ax",%progbits
 1359              	 .align 2
 1360              	 .global CheckSyncTypeValue
 1361              	 .thumb
 1362              	 .thumb_func
 1364              	CheckSyncTypeValue:
 1365              	.LFB181:
 712:../SSC/Src/objdef.c **** 
 713:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 714:../SSC/Src/objdef.c **** /**
 715:../SSC/Src/objdef.c ****  \param     index                 index of the SyncManager Parameter object 
 716:../SSC/Src/objdef.c ****  \param     NewSyncType           New value for the Sync Type (SubIndex 1)
 717:../SSC/Src/objdef.c **** 
 718:../SSC/Src/objdef.c ****  \return    result                Result of the value validation
 719:../SSC/Src/objdef.c **** 
 720:../SSC/Src/objdef.c ****  \brief    Checks if the new Sync type value is valid
 721:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 722:../SSC/Src/objdef.c **** UINT8 CheckSyncTypeValue(UINT16 index, UINT16 NewSyncType)
 723:../SSC/Src/objdef.c **** {
 1366              	 .loc 1 723 0
 1367              	 .cfi_startproc
 1368              	 
 1369              	 
 1370              	 
 1371 0000 80B4     	 push {r7}
 1372              	.LCFI50:
 1373              	 .cfi_def_cfa_offset 4
 1374              	 .cfi_offset 7,-4
 1375 0002 83B0     	 sub sp,sp,#12
 1376              	.LCFI51:
 1377              	 .cfi_def_cfa_offset 16
 1378 0004 00AF     	 add r7,sp,#0
 1379              	.LCFI52:
 1380              	 .cfi_def_cfa_register 7
 1381 0006 0346     	 mov r3,r0
 1382 0008 0A46     	 mov r2,r1
 1383 000a FB80     	 strh r3,[r7,#6]
 1384 000c 1346     	 mov r3,r2
 1385 000e BB80     	 strh r3,[r7,#4]
 724:../SSC/Src/objdef.c ****     /*ECATCHANGE_START(V5.11) ESM7*/
 725:../SSC/Src/objdef.c ****     switch (NewSyncType)
 1386              	 .loc 1 725 0
 1387 0010 BB88     	 ldrh r3,[r7,#4]
 1388 0012 222B     	 cmp r3,#34
 1389 0014 00F2BB80 	 bhi .L93
 1390 0018 01A2     	 adr r2,.L95
 1391 001a 52F823F0 	 ldr pc,[r2,r3,lsl#2]
 1392 001e 00BF     	 .p2align 2
 1393              	.L95:
 1394 0020 AD000000 	 .word .L94+1
 1395 0024 B1000000 	 .word .L96+1
 1396 0028 23010000 	 .word .L97+1
 1397 002c 59010000 	 .word .L98+1
 1398 0030 8F010000 	 .word .L93+1
 1399 0034 8F010000 	 .word .L93+1
 1400 0038 8F010000 	 .word .L93+1
 1401 003c 8F010000 	 .word .L93+1
 1402 0040 8F010000 	 .word .L93+1
 1403 0044 8F010000 	 .word .L93+1
 1404 0048 8F010000 	 .word .L93+1
 1405 004c 8F010000 	 .word .L93+1
 1406 0050 8F010000 	 .word .L93+1
 1407 0054 8F010000 	 .word .L93+1
 1408 0058 8F010000 	 .word .L93+1
 1409 005c 8F010000 	 .word .L93+1
 1410 0060 8F010000 	 .word .L93+1
 1411 0064 8F010000 	 .word .L93+1
 1412 0068 8F010000 	 .word .L93+1
 1413 006c 8F010000 	 .word .L93+1
 1414 0070 8F010000 	 .word .L93+1
 1415 0074 8F010000 	 .word .L93+1
 1416 0078 8F010000 	 .word .L93+1
 1417 007c 8F010000 	 .word .L93+1
 1418 0080 8F010000 	 .word .L93+1
 1419 0084 8F010000 	 .word .L93+1
 1420 0088 8F010000 	 .word .L93+1
 1421 008c 8F010000 	 .word .L93+1
 1422 0090 8F010000 	 .word .L93+1
 1423 0094 8F010000 	 .word .L93+1
 1424 0098 8F010000 	 .word .L93+1
 1425 009c 8F010000 	 .word .L93+1
 1426 00a0 8F010000 	 .word .L93+1
 1427 00a4 8F010000 	 .word .L93+1
 1428 00a8 FF000000 	 .word .L99+1
 1429              	 .p2align 1
 1430              	.L94:
 726:../SSC/Src/objdef.c ****     {
 727:../SSC/Src/objdef.c ****     case SYNCTYPE_FREERUN:
 728:../SSC/Src/objdef.c ****         return 0; //free run sync mode is always accepted
 1431              	 .loc 1 728 0
 1432 00ac 0023     	 movs r3,#0
 1433 00ae 6FE0     	 b .L100
 1434              	.L96:
 729:../SSC/Src/objdef.c ****         break;
 730:../SSC/Src/objdef.c **** 
 731:../SSC/Src/objdef.c ****     case SYNCTYPE_SM_SYNCHRON:
 732:../SSC/Src/objdef.c ****         if ((index == 0x1C32) 
 1435              	 .loc 1 732 0
 1436 00b0 FB88     	 ldrh r3,[r7,#6]
 1437 00b2 41F63242 	 movw r2,#7218
 1438 00b6 9342     	 cmp r3,r2
 1439 00b8 0BD1     	 bne .L101
 733:../SSC/Src/objdef.c ****             && (nPdOutputSize > 0) 
 1440              	 .loc 1 733 0
 1441 00ba 384B     	 ldr r3,.L108
 1442 00bc 1B88     	 ldrh r3,[r3]
 1443 00be 002B     	 cmp r3,#0
 1444 00c0 07D0     	 beq .L101
 734:../SSC/Src/objdef.c ****             && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0))
 1445              	 .loc 1 734 0
 1446 00c2 374B     	 ldr r3,.L108+4
 1447 00c4 9B89     	 ldrh r3,[r3,#12]
 1448 00c6 03F00203 	 and r3,r3,#2
 1449 00ca 002B     	 cmp r3,#0
 1450 00cc 01DD     	 ble .L101
 735:../SSC/Src/objdef.c ****         {
 736:../SSC/Src/objdef.c ****             /*SyncManager sync mode is supported and output process data is configured*/
 737:../SSC/Src/objdef.c ****             return 0;
 1451              	 .loc 1 737 0
 1452 00ce 0023     	 movs r3,#0
 1453 00d0 5EE0     	 b .L100
 1454              	.L101:
 738:../SSC/Src/objdef.c ****         }
 739:../SSC/Src/objdef.c ****         else
 740:../SSC/Src/objdef.c ****         if ((index == 0x1C33) 
 1455              	 .loc 1 740 0
 1456 00d2 FB88     	 ldrh r3,[r7,#6]
 1457 00d4 41F63342 	 movw r2,#7219
 1458 00d8 9342     	 cmp r3,r2
 1459 00da 0FD1     	 bne .L102
 741:../SSC/Src/objdef.c ****             && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
 1460              	 .loc 1 741 0
 1461 00dc 314B     	 ldr r3,.L108+8
 1462 00de 9B89     	 ldrh r3,[r3,#12]
 1463 00e0 03F00203 	 and r3,r3,#2
 1464 00e4 002B     	 cmp r3,#0
 1465 00e6 09DD     	 ble .L102
 742:../SSC/Src/objdef.c ****             && (nPdOutputSize == 0) 
 1466              	 .loc 1 742 0
 1467 00e8 2C4B     	 ldr r3,.L108
 1468 00ea 1B88     	 ldrh r3,[r3]
 1469 00ec 002B     	 cmp r3,#0
 1470 00ee 05D1     	 bne .L102
 743:../SSC/Src/objdef.c ****             && (nPdInputSize > 0))
 1471              	 .loc 1 743 0
 1472 00f0 2D4B     	 ldr r3,.L108+12
 1473 00f2 1B88     	 ldrh r3,[r3]
 1474 00f4 002B     	 cmp r3,#0
 1475 00f6 01D0     	 beq .L102
 744:../SSC/Src/objdef.c ****             {
 745:../SSC/Src/objdef.c ****                 /*SyncManager sync mode is supported and input only shall be configured*/
 746:../SSC/Src/objdef.c ****                 return 0;
 1476              	 .loc 1 746 0
 1477 00f8 0023     	 movs r3,#0
 1478 00fa 49E0     	 b .L100
 1479              	.L102:
 747:../SSC/Src/objdef.c ****             }
 748:../SSC/Src/objdef.c ****         break;
 1480              	 .loc 1 748 0
 1481 00fc 47E0     	 b .L93
 1482              	.L99:
 749:../SSC/Src/objdef.c **** 
 750:../SSC/Src/objdef.c ****     case SYNCTYPE_SM2_SYNCHRON:
 751:../SSC/Src/objdef.c ****         if ((index == 0x1C33) 
 1483              	 .loc 1 751 0
 1484 00fe FB88     	 ldrh r3,[r7,#6]
 1485 0100 41F63342 	 movw r2,#7219
 1486 0104 9342     	 cmp r3,r2
 1487 0106 0BD1     	 bne .L103
 752:../SSC/Src/objdef.c ****             && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
 1488              	 .loc 1 752 0
 1489 0108 264B     	 ldr r3,.L108+8
 1490 010a 9B89     	 ldrh r3,[r3,#12]
 1491 010c 03F00203 	 and r3,r3,#2
 1492 0110 002B     	 cmp r3,#0
 1493 0112 05DD     	 ble .L103
 753:../SSC/Src/objdef.c ****             && (nPdOutputSize > 0))
 1494              	 .loc 1 753 0
 1495 0114 214B     	 ldr r3,.L108
 1496 0116 1B88     	 ldrh r3,[r3]
 1497 0118 002B     	 cmp r3,#0
 1498 011a 01D0     	 beq .L103
 754:../SSC/Src/objdef.c ****             {
 755:../SSC/Src/objdef.c ****                 /*SyncManager sync mode is supported and outputs are defined*/
 756:../SSC/Src/objdef.c ****                 return 0;
 1499              	 .loc 1 756 0
 1500 011c 0023     	 movs r3,#0
 1501 011e 37E0     	 b .L100
 1502              	.L103:
 757:../SSC/Src/objdef.c ****             }
 758:../SSC/Src/objdef.c ****         break;
 1503              	 .loc 1 758 0
 1504 0120 35E0     	 b .L93
 1505              	.L97:
 759:../SSC/Src/objdef.c **** 
 760:../SSC/Src/objdef.c ****     case SYNCTYPE_DCSYNC0:
 761:../SSC/Src/objdef.c ****         if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0
 1506              	 .loc 1 761 0
 1507 0122 FB88     	 ldrh r3,[r7,#6]
 1508 0124 41F63242 	 movw r2,#7218
 1509 0128 9342     	 cmp r3,r2
 1510 012a 07D1     	 bne .L104
 1511              	 .loc 1 761 0 is_stmt 0 discriminator 1
 1512 012c 1C4B     	 ldr r3,.L108+4
 1513 012e 9B89     	 ldrh r3,[r3,#12]
 1514 0130 03F00403 	 and r3,r3,#4
 1515 0134 002B     	 cmp r3,#0
 1516 0136 01DD     	 ble .L104
 762:../SSC/Src/objdef.c ****         {
 763:../SSC/Src/objdef.c ****             return 0;
 1517              	 .loc 1 763 0 is_stmt 1
 1518 0138 0023     	 movs r3,#0
 1519 013a 29E0     	 b .L100
 1520              	.L104:
 764:../SSC/Src/objdef.c ****         }
 765:../SSC/Src/objdef.c ****         else
 766:../SSC/Src/objdef.c ****         if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0)
 1521              	 .loc 1 766 0
 1522 013c FB88     	 ldrh r3,[r7,#6]
 1523 013e 41F63342 	 movw r2,#7219
 1524 0142 9342     	 cmp r3,r2
 1525 0144 07D1     	 bne .L105
 1526              	 .loc 1 766 0 is_stmt 0 discriminator 1
 1527 0146 174B     	 ldr r3,.L108+8
 1528 0148 9B89     	 ldrh r3,[r3,#12]
 1529 014a 03F00403 	 and r3,r3,#4
 1530 014e 002B     	 cmp r3,#0
 1531 0150 01DD     	 ble .L105
 767:../SSC/Src/objdef.c ****         {
 768:../SSC/Src/objdef.c ****             return 0;
 1532              	 .loc 1 768 0 is_stmt 1
 1533 0152 0023     	 movs r3,#0
 1534 0154 1CE0     	 b .L100
 1535              	.L105:
 769:../SSC/Src/objdef.c ****         }
 770:../SSC/Src/objdef.c ****         break;
 1536              	 .loc 1 770 0
 1537 0156 1AE0     	 b .L93
 1538              	.L98:
 771:../SSC/Src/objdef.c **** 
 772:../SSC/Src/objdef.c ****     case SYNCTYPE_DCSYNC1:
 773:../SSC/Src/objdef.c ****         if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0
 1539              	 .loc 1 773 0
 1540 0158 FB88     	 ldrh r3,[r7,#6]
 1541 015a 41F63242 	 movw r2,#7218
 1542 015e 9342     	 cmp r3,r2
 1543 0160 07D1     	 bne .L106
 1544              	 .loc 1 773 0 is_stmt 0 discriminator 1
 1545 0162 0F4B     	 ldr r3,.L108+4
 1546 0164 9B89     	 ldrh r3,[r3,#12]
 1547 0166 03F00803 	 and r3,r3,#8
 1548 016a 002B     	 cmp r3,#0
 1549 016c 01DD     	 ble .L106
 774:../SSC/Src/objdef.c ****         {
 775:../SSC/Src/objdef.c ****             return 0;
 1550              	 .loc 1 775 0 is_stmt 1
 1551 016e 0023     	 movs r3,#0
 1552 0170 0EE0     	 b .L100
 1553              	.L106:
 776:../SSC/Src/objdef.c ****         }
 777:../SSC/Src/objdef.c ****         else
 778:../SSC/Src/objdef.c ****         if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0)
 1554              	 .loc 1 778 0
 1555 0172 FB88     	 ldrh r3,[r7,#6]
 1556 0174 41F63342 	 movw r2,#7219
 1557 0178 9342     	 cmp r3,r2
 1558 017a 07D1     	 bne .L107
 1559              	 .loc 1 778 0 is_stmt 0 discriminator 1
 1560 017c 094B     	 ldr r3,.L108+8
 1561 017e 9B89     	 ldrh r3,[r3,#12]
 1562 0180 03F00803 	 and r3,r3,#8
 1563 0184 002B     	 cmp r3,#0
 1564 0186 01DD     	 ble .L107
 779:../SSC/Src/objdef.c ****         {
 780:../SSC/Src/objdef.c ****             return 0;
 1565              	 .loc 1 780 0 is_stmt 1
 1566 0188 0023     	 movs r3,#0
 1567 018a 01E0     	 b .L100
 1568              	.L107:
 781:../SSC/Src/objdef.c ****         }
 782:../SSC/Src/objdef.c ****         break;
 1569              	 .loc 1 782 0
 1570 018c 00BF     	 nop
 1571              	.L93:
 783:../SSC/Src/objdef.c ****     } //switch 
 784:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) ESM7*/
 785:../SSC/Src/objdef.c ****     return ABORTIDX_VALUE_EXCEEDED;
 1572              	 .loc 1 785 0
 1573 018e 1223     	 movs r3,#18
 1574              	.L100:
 786:../SSC/Src/objdef.c **** 
 787:../SSC/Src/objdef.c **** }
 1575              	 .loc 1 787 0
 1576 0190 1846     	 mov r0,r3
 1577 0192 0C37     	 adds r7,r7,#12
 1578              	.LCFI53:
 1579              	 .cfi_def_cfa_offset 4
 1580 0194 BD46     	 mov sp,r7
 1581              	.LCFI54:
 1582              	 .cfi_def_cfa_register 13
 1583              	 
 1584 0196 5DF8047B 	 ldr r7,[sp],#4
 1585              	.LCFI55:
 1586              	 .cfi_restore 7
 1587              	 .cfi_def_cfa_offset 0
 1588 019a 7047     	 bx lr
 1589              	.L109:
 1590              	 .align 2
 1591              	.L108:
 1592 019c 00000000 	 .word nPdOutputSize
 1593 01a0 00000000 	 .word sSyncManOutPar
 1594 01a4 00000000 	 .word sSyncManInPar
 1595 01a8 00000000 	 .word nPdInputSize
 1596              	 .cfi_endproc
 1597              	.LFE181:
 1599              	 .section .text.OBJ_Read,"ax",%progbits
 1600              	 .align 2
 1601              	 .global OBJ_Read
 1602              	 .thumb
 1603              	 .thumb_func
 1605              	OBJ_Read:
 1606              	.LFB182:
 788:../SSC/Src/objdef.c **** 
 789:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 790:../SSC/Src/objdef.c **** /**
 791:../SSC/Src/objdef.c ****  \param     index                 index of the requested object.
 792:../SSC/Src/objdef.c ****  \param     subindex                subindex of the requested object.
 793:../SSC/Src/objdef.c ****  \param    objSize                Size of the object, returned by the function OBJ_GetObjectLength
 794:../SSC/Src/objdef.c ****                                      which was called before
 795:../SSC/Src/objdef.c ****  \param     pObjEntry            handle to the dictionary object returned by
 796:../SSC/Src/objdef.c ****                                      OBJ_GetObjectHandle which was called before
 797:../SSC/Src/objdef.c ****  \param    pData                    Pointer to the buffer where the read data shall be copied to
 798:../SSC/Src/objdef.c ****  \param    bCompleteAccess    Indicates if a complete read of all subindices of the
 799:../SSC/Src/objdef.c ****                                      object shall be done or not
 800:../SSC/Src/objdef.c **** 
 801:../SSC/Src/objdef.c ****  \return    result of the read operation (0 (success) or an abort code (ABORTIDX_.... defined in
 802:../SSC/Src/objdef.c ****             sdosrv.h))
 803:../SSC/Src/objdef.c **** 
 804:../SSC/Src/objdef.c ****  \brief    This function reads the requested object
 805:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 806:../SSC/Src/objdef.c **** 
 807:../SSC/Src/objdef.c **** UINT8 OBJ_Read( UINT16 index, UINT8 subindex, UINT32 objSize, OBJCONST TOBJECT OBJMEM * pObjEntry, 
 808:../SSC/Src/objdef.c **** {
 1607              	 .loc 1 808 0
 1608              	 .cfi_startproc
 1609              	 
 1610              	 
 1611 0000 90B5     	 push {r4,r7,lr}
 1612              	.LCFI56:
 1613              	 .cfi_def_cfa_offset 12
 1614              	 .cfi_offset 4,-12
 1615              	 .cfi_offset 7,-8
 1616              	 .cfi_offset 14,-4
 1617 0002 91B0     	 sub sp,sp,#68
 1618              	.LCFI57:
 1619              	 .cfi_def_cfa_offset 80
 1620 0004 02AF     	 add r7,sp,#8
 1621              	.LCFI58:
 1622              	 .cfi_def_cfa 7,72
 1623 0006 BA60     	 str r2,[r7,#8]
 1624 0008 7B60     	 str r3,[r7,#4]
 1625 000a 0346     	 mov r3,r0
 1626 000c FB81     	 strh r3,[r7,#14]
 1627 000e 0B46     	 mov r3,r1
 1628 0010 7B73     	 strb r3,[r7,#13]
 809:../SSC/Src/objdef.c ****     UINT16 i = subindex;
 1629              	 .loc 1 809 0
 1630 0012 7B7B     	 ldrb r3,[r7,#13]
 1631 0014 FB86     	 strh r3,[r7,#54]
 810:../SSC/Src/objdef.c ****     /* get the information of ObjCode and MaxSubindex in local variables to support different types
 811:../SSC/Src/objdef.c ****     UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 1632              	 .loc 1 811 0
 1633 0016 7B68     	 ldr r3,[r7,#4]
 1634 0018 9B89     	 ldrh r3,[r3,#12]
 1635 001a 03F47063 	 and r3,r3,#3840
 1636 001e 1B12     	 asrs r3,r3,#8
 1637 0020 87F82A30 	 strb r3,[r7,#42]
 812:../SSC/Src/objdef.c ****     UINT16 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSU
 1638              	 .loc 1 812 0
 1639 0024 7B68     	 ldr r3,[r7,#4]
 1640 0026 9B89     	 ldrh r3,[r3,#12]
 1641 0028 DBB2     	 uxtb r3,r3
 1642 002a BB86     	 strh r3,[r7,#52]
 813:../SSC/Src/objdef.c ****     OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
 814:../SSC/Src/objdef.c ****     /* lastSubindex is used for complete access to make loop over the requested entries
 815:../SSC/Src/objdef.c ****     to be read, we initialize this variable with the requested subindex that only
 816:../SSC/Src/objdef.c ****     one loop will be done for a single access */
 817:../SSC/Src/objdef.c ****     UINT16 lastSubindex = subindex;
 1643              	 .loc 1 817 0
 1644 002c 7B7B     	 ldrb r3,[r7,#13]
 1645 002e 7B86     	 strh r3,[r7,#50]
 818:../SSC/Src/objdef.c **** 
 819:../SSC/Src/objdef.c ****     if ( objCode != OBJCODE_VAR && index >= 0x1000 )
 1646              	 .loc 1 819 0
 1647 0030 97F82A30 	 ldrb r3,[r7,#42]
 1648 0034 072B     	 cmp r3,#7
 1649 0036 08D0     	 beq .L111
 1650              	 .loc 1 819 0 is_stmt 0 discriminator 1
 1651 0038 FB89     	 ldrh r3,[r7,#14]
 1652 003a B3F5805F 	 cmp r3,#4096
 1653 003e 04D3     	 bcc .L111
 820:../SSC/Src/objdef.c ****     {
 821:../SSC/Src/objdef.c ****         /* if the object is an array or record we have to get the maxSubindex from the
 822:../SSC/Src/objdef.c ****         actual value of subindex 0, which is stored as UINT16 at the beginning of the
 823:../SSC/Src/objdef.c ****         object's variable */
 824:../SSC/Src/objdef.c ****         maxSubindex = (*((UINT16 *) (pObjEntry->pVarPtr))) & 0x00FF;
 1654              	 .loc 1 824 0 is_stmt 1
 1655 0040 7B68     	 ldr r3,[r7,#4]
 1656 0042 9B69     	 ldr r3,[r3,#24]
 1657 0044 1B88     	 ldrh r3,[r3]
 1658 0046 DBB2     	 uxtb r3,r3
 1659 0048 BB86     	 strh r3,[r7,#52]
 1660              	.L111:
 825:../SSC/Src/objdef.c **** 
 826:../SSC/Src/objdef.c ****     }
 827:../SSC/Src/objdef.c **** 
 828:../SSC/Src/objdef.c ****     if ( bCompleteAccess )
 1661              	 .loc 1 828 0
 1662 004a 97F84C30 	 ldrb r3,[r7,#76]
 1663 004e 002B     	 cmp r3,#0
 1664 0050 0CD0     	 beq .L112
 829:../SSC/Src/objdef.c ****     {
 830:../SSC/Src/objdef.c ****         if ( objCode == OBJCODE_VAR || index < 0x1000 )
 1665              	 .loc 1 830 0
 1666 0052 97F82A30 	 ldrb r3,[r7,#42]
 1667 0056 072B     	 cmp r3,#7
 1668 0058 03D0     	 beq .L113
 1669              	 .loc 1 830 0 is_stmt 0 discriminator 1
 1670 005a FB89     	 ldrh r3,[r7,#14]
 1671 005c B3F5805F 	 cmp r3,#4096
 1672 0060 01D2     	 bcs .L114
 1673              	.L113:
 831:../SSC/Src/objdef.c ****         {
 832:../SSC/Src/objdef.c ****             /* complete access is not supported with simple objects or ENUM descriptions */
 833:../SSC/Src/objdef.c ****             return ABORTIDX_UNSUPPORTED_ACCESS;
 1674              	 .loc 1 833 0 is_stmt 1
 1675 0062 0523     	 movs r3,#5
 1676 0064 9AE2     	 b .L115
 1677              	.L114:
 834:../SSC/Src/objdef.c ****         }
 835:../SSC/Src/objdef.c **** 
 836:../SSC/Src/objdef.c ****         /* we read until the maximum subindex */
 837:../SSC/Src/objdef.c ****         lastSubindex = maxSubindex;
 1678              	 .loc 1 837 0
 1679 0066 BB8E     	 ldrh r3,[r7,#52]
 1680 0068 7B86     	 strh r3,[r7,#50]
 1681 006a 2AE0     	 b .L116
 1682              	.L112:
 838:../SSC/Src/objdef.c ****     }
 839:../SSC/Src/objdef.c ****     else
 840:../SSC/Src/objdef.c ****         if ( subindex > maxSubindex )
 1683              	 .loc 1 840 0
 1684 006c 7B7B     	 ldrb r3,[r7,#13]
 1685 006e 9BB2     	 uxth r3,r3
 1686 0070 BA8E     	 ldrh r2,[r7,#52]
 1687 0072 9A42     	 cmp r2,r3
 1688 0074 01D2     	 bcs .L117
 841:../SSC/Src/objdef.c ****         {
 842:../SSC/Src/objdef.c ****             /* the maximum subindex is reached */
 843:../SSC/Src/objdef.c ****             return ABORTIDX_SUBINDEX_NOT_EXISTING;
 1689              	 .loc 1 843 0
 1690 0076 1123     	 movs r3,#17
 1691 0078 90E2     	 b .L115
 1692              	.L117:
 844:../SSC/Src/objdef.c ****         }
 845:../SSC/Src/objdef.c ****         else
 846:../SSC/Src/objdef.c ****         {
 847:../SSC/Src/objdef.c ****             /* get the corresponding entry description */
 848:../SSC/Src/objdef.c ****             pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
 1693              	 .loc 1 848 0
 1694 007a FB8E     	 ldrh r3,[r7,#54]
 1695 007c DBB2     	 uxtb r3,r3
 1696 007e 7868     	 ldr r0,[r7,#4]
 1697 0080 1946     	 mov r1,r3
 1698 0082 FFF7FEFF 	 bl OBJ_GetEntryDesc
 1699 0086 7862     	 str r0,[r7,#36]
 849:../SSC/Src/objdef.c **** 
 850:../SSC/Src/objdef.c ****             /*Check access only for non-align entries*/
 851:../SSC/Src/objdef.c ****             if(pEntry->ObjAccess != 0x0)
 1700              	 .loc 1 851 0
 1701 0088 7B6A     	 ldr r3,[r7,#36]
 1702 008a 9B88     	 ldrh r3,[r3,#4]
 1703 008c 002B     	 cmp r3,#0
 1704 008e 18D0     	 beq .L116
 852:../SSC/Src/objdef.c ****             {
 853:../SSC/Src/objdef.c ****                 /* check if we have read access (bits 0-2 (PREOP, SAFEOP, OP) of ObjAccess)
 854:../SSC/Src/objdef.c ****                 by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
 855:../SSC/Src/objdef.c ****                 if ( ((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) < (nAlStatus & STATE_MASK) )
 1705              	 .loc 1 855 0
 1706 0090 7B6A     	 ldr r3,[r7,#36]
 1707 0092 9B88     	 ldrh r3,[r3,#4]
 1708 0094 DBB2     	 uxtb r3,r3
 1709 0096 03F00703 	 and r3,r3,#7
 1710 009a DBB2     	 uxtb r3,r3
 1711 009c 5B00     	 lsls r3,r3,#1
 1712 009e DBB2     	 uxtb r3,r3
 1713 00a0 1A46     	 mov r2,r3
 1714 00a2 9E4B     	 ldr r3,.L168
 1715 00a4 1B78     	 ldrb r3,[r3]
 1716 00a6 03F00F03 	 and r3,r3,#15
 1717 00aa 9A42     	 cmp r2,r3
 1718 00ac 09DA     	 bge .L116
 856:../SSC/Src/objdef.c ****                 {
 857:../SSC/Src/objdef.c ****                     /* we don't have read access */
 858:../SSC/Src/objdef.c ****                     if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
 1719              	 .loc 1 858 0
 1720 00ae 7B6A     	 ldr r3,[r7,#36]
 1721 00b0 9B88     	 ldrh r3,[r3,#4]
 1722 00b2 03F00703 	 and r3,r3,#7
 1723 00b6 002B     	 cmp r3,#0
 1724 00b8 01D1     	 bne .L118
 859:../SSC/Src/objdef.c ****                     {
 860:../SSC/Src/objdef.c ****                         /* it is a write only entry */
 861:../SSC/Src/objdef.c ****                         return ABORTIDX_WRITE_ONLY_ENTRY;
 1725              	 .loc 1 861 0
 1726 00ba 0623     	 movs r3,#6
 1727 00bc 6EE2     	 b .L115
 1728              	.L118:
 862:../SSC/Src/objdef.c ****                     }
 863:../SSC/Src/objdef.c ****                     else
 864:../SSC/Src/objdef.c ****                     {
 865:../SSC/Src/objdef.c ****                         /* we don't have read access in this state */
 866:../SSC/Src/objdef.c ****                         return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
 1729              	 .loc 1 866 0
 1730 00be 1A23     	 movs r3,#26
 1731 00c0 6CE2     	 b .L115
 1732              	.L116:
 867:../SSC/Src/objdef.c ****                     }
 868:../SSC/Src/objdef.c ****                 }
 869:../SSC/Src/objdef.c ****             }
 870:../SSC/Src/objdef.c ****         }
 871:../SSC/Src/objdef.c ****         if ( pObjEntry->Read != NULL )
 1733              	 .loc 1 871 0
 1734 00c2 7B68     	 ldr r3,[r7,#4]
 1735 00c4 DB69     	 ldr r3,[r3,#28]
 1736 00c6 002B     	 cmp r3,#0
 1737 00c8 0DD0     	 beq .L119
 872:../SSC/Src/objdef.c ****         {
 873:../SSC/Src/objdef.c ****             /* Read function is defined, we call the object specific read function */
 874:../SSC/Src/objdef.c ****             return pObjEntry->Read(index, subindex, objSize, pData, bCompleteAccess);
 1738              	 .loc 1 874 0
 1739 00ca 7B68     	 ldr r3,[r7,#4]
 1740 00cc DC69     	 ldr r4,[r3,#28]
 1741 00ce F989     	 ldrh r1,[r7,#14]
 1742 00d0 7A7B     	 ldrb r2,[r7,#13]
 1743 00d2 97F84C30 	 ldrb r3,[r7,#76]
 1744 00d6 0093     	 str r3,[sp]
 1745 00d8 0846     	 mov r0,r1
 1746 00da 1146     	 mov r1,r2
 1747 00dc BA68     	 ldr r2,[r7,#8]
 1748 00de BB6C     	 ldr r3,[r7,#72]
 1749 00e0 A047     	 blx r4
 1750 00e2 0346     	 mov r3,r0
 1751 00e4 5AE2     	 b .L115
 1752              	.L119:
 875:../SSC/Src/objdef.c ****         }
 876:../SSC/Src/objdef.c ****         else if ( index < 0x1000 && subindex != 0 )
 1753              	 .loc 1 876 0
 1754 00e6 FB89     	 ldrh r3,[r7,#14]
 1755 00e8 B3F5805F 	 cmp r3,#4096
 1756 00ec 32D2     	 bcs .L120
 1757              	 .loc 1 876 0 is_stmt 0 discriminator 1
 1758 00ee 7B7B     	 ldrb r3,[r7,#13]
 1759 00f0 002B     	 cmp r3,#0
 1760 00f2 2FD0     	 beq .L120
 1761              	.LBB10:
 877:../SSC/Src/objdef.c ****         {
 878:../SSC/Src/objdef.c ****             /* an ENUM description is read */
 879:../SSC/Src/objdef.c ****             UINT16 size;
 880:../SSC/Src/objdef.c ****             UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
 1762              	 .loc 1 880 0 is_stmt 1
 1763 00f4 7B68     	 ldr r3,[r7,#4]
 1764 00f6 9B69     	 ldr r3,[r3,#24]
 1765 00f8 3B62     	 str r3,[r7,#32]
 881:../SSC/Src/objdef.c ****             CHAR **p;
 882:../SSC/Src/objdef.c **** 
 883:../SSC/Src/objdef.c ****             /* we get the corresponding entry description */
 884:../SSC/Src/objdef.c ****             pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
 1766              	 .loc 1 884 0
 1767 00fa 7B7B     	 ldrb r3,[r7,#13]
 1768 00fc 7868     	 ldr r0,[r7,#4]
 1769 00fe 1946     	 mov r1,r3
 1770 0100 FFF7FEFF 	 bl OBJ_GetEntryDesc
 1771 0104 7862     	 str r0,[r7,#36]
 885:../SSC/Src/objdef.c ****             size = BIT2BYTE(pEntry->BitLength);
 1772              	 .loc 1 885 0
 1773 0106 7B6A     	 ldr r3,[r7,#36]
 1774 0108 5B88     	 ldrh r3,[r3,#2]
 1775 010a 0733     	 adds r3,r3,#7
 1776 010c DB10     	 asrs r3,r3,#3
 1777 010e FB83     	 strh r3,[r7,#30]
 886:../SSC/Src/objdef.c **** 
 887:../SSC/Src/objdef.c ****             p = (CHAR **) pVarPtr;
 1778              	 .loc 1 887 0
 1779 0110 3B6A     	 ldr r3,[r7,#32]
 1780 0112 BB61     	 str r3,[r7,#24]
 888:../SSC/Src/objdef.c ****             pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
 1781              	 .loc 1 888 0
 1782 0114 7B7B     	 ldrb r3,[r7,#13]
 1783 0116 03F18043 	 add r3,r3,#1073741824
 1784 011a 013B     	 subs r3,r3,#1
 1785 011c 9B00     	 lsls r3,r3,#2
 1786 011e BA69     	 ldr r2,[r7,#24]
 1787 0120 1344     	 add r3,r3,r2
 1788 0122 1B68     	 ldr r3,[r3]
 1789 0124 3B62     	 str r3,[r7,#32]
 889:../SSC/Src/objdef.c **** 
 890:../SSC/Src/objdef.c ****             {
 891:../SSC/Src/objdef.c ****             // Get enum value (first 32Bit)
 892:../SSC/Src/objdef.c ****             pData[0] = pVarPtr[0];
 1790              	 .loc 1 892 0
 1791 0126 3B6A     	 ldr r3,[r7,#32]
 1792 0128 1A88     	 ldrh r2,[r3]
 1793 012a BB6C     	 ldr r3,[r7,#72]
 1794 012c 1A80     	 strh r2,[r3]
 893:../SSC/Src/objdef.c ****             pData[1] = pVarPtr[1];
 1795              	 .loc 1 893 0
 1796 012e BB6C     	 ldr r3,[r7,#72]
 1797 0130 0233     	 adds r3,r3,#2
 1798 0132 3A6A     	 ldr r2,[r7,#32]
 1799 0134 5288     	 ldrh r2,[r2,#2]
 1800 0136 1A80     	 strh r2,[r3]
 894:../SSC/Src/objdef.c ****             pData += 2;
 1801              	 .loc 1 894 0
 1802 0138 BB6C     	 ldr r3,[r7,#72]
 1803 013a 0433     	 adds r3,r3,#4
 1804 013c BB64     	 str r3,[r7,#72]
 895:../SSC/Src/objdef.c ****             pVarPtr += 2;
 1805              	 .loc 1 895 0
 1806 013e 3B6A     	 ldr r3,[r7,#32]
 1807 0140 0433     	 adds r3,r3,#4
 1808 0142 3B62     	 str r3,[r7,#32]
 896:../SSC/Src/objdef.c **** 
 897:../SSC/Src/objdef.c ****             // Get enum description
 898:../SSC/Src/objdef.c ****             OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
 1809              	 .loc 1 898 0
 1810 0144 FB8B     	 ldrh r3,[r7,#30]
 1811 0146 043B     	 subs r3,r3,#4
 1812 0148 B86C     	 ldr r0,[r7,#72]
 1813 014a 396A     	 ldr r1,[r7,#32]
 1814 014c 1A46     	 mov r2,r3
 1815 014e FFF7FEFF 	 bl memcpy
 1816              	.LBE10:
 877:../SSC/Src/objdef.c ****             /* an ENUM description is read */
 1817              	 .loc 1 877 0
 1818 0152 22E2     	 b .L121
 1819              	.L120:
 1820              	.LBB11:
 899:../SSC/Src/objdef.c ****             }
 900:../SSC/Src/objdef.c ****         }
 901:../SSC/Src/objdef.c ****         else
 902:../SSC/Src/objdef.c ****         {
 903:../SSC/Src/objdef.c ****             UINT8 bRead = 0x0;
 1821              	 .loc 1 903 0
 1822 0154 0023     	 movs r3,#0
 1823 0156 87F83130 	 strb r3,[r7,#49]
 904:../SSC/Src/objdef.c ****             UINT8 result = 0;
 1824              	 .loc 1 904 0
 1825 015a 0023     	 movs r3,#0
 1826 015c 87F83030 	 strb r3,[r7,#48]
 905:../SSC/Src/objdef.c **** 
 906:../SSC/Src/objdef.c **** 
 907:../SSC/Src/objdef.c ****             /* a variable object is read */
 908:../SSC/Src/objdef.c ****             for (i = subindex; i <= lastSubindex; i++)
 1827              	 .loc 1 908 0
 1828 0160 7B7B     	 ldrb r3,[r7,#13]
 1829 0162 FB86     	 strh r3,[r7,#54]
 1830 0164 0DE2     	 b .L122
 1831              	.L167:
 1832              	.LBB12:
 909:../SSC/Src/objdef.c ****             {
 910:../SSC/Src/objdef.c ****                 /* if only a single entry is requested, this loop will only be done once */
 911:../SSC/Src/objdef.c ****                 UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
 1833              	 .loc 1 911 0
 1834 0166 7B68     	 ldr r3,[r7,#4]
 1835 0168 9B69     	 ldr r3,[r3,#24]
 1836 016a 7B61     	 str r3,[r7,#20]
 912:../SSC/Src/objdef.c ****                 UINT16 bitOffset = 0;
 1837              	 .loc 1 912 0
 1838 016c 0023     	 movs r3,#0
 1839 016e FB85     	 strh r3,[r7,#46]
 913:../SSC/Src/objdef.c **** 
 914:../SSC/Src/objdef.c ****                 if (i == 0)
 1840              	 .loc 1 914 0
 1841 0170 FB8E     	 ldrh r3,[r7,#54]
 1842 0172 002B     	 cmp r3,#0
 1843 0174 0BD0     	 beq .L123
 915:../SSC/Src/objdef.c ****                 {
 916:../SSC/Src/objdef.c ****                     /* subindex 0 is requested, the entry's data is at the beginning of the object'
 917:../SSC/Src/objdef.c ****                 }
 918:../SSC/Src/objdef.c ****                 else if ( index >= 0x1000 )
 1844              	 .loc 1 918 0
 1845 0176 FB89     	 ldrh r3,[r7,#14]
 1846 0178 B3F5805F 	 cmp r3,#4096
 1847 017c 07D3     	 bcc .L123
 919:../SSC/Src/objdef.c ****                 {
 920:../SSC/Src/objdef.c ****                     /* subindex 1-n of an variable object is requested, we get the offset of the va
 921:../SSC/Src/objdef.c ****                     bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
 1848              	 .loc 1 921 0
 1849 017e FB8E     	 ldrh r3,[r7,#54]
 1850 0180 DBB2     	 uxtb r3,r3
 1851 0182 1846     	 mov r0,r3
 1852 0184 7968     	 ldr r1,[r7,#4]
 1853 0186 FFF7FEFF 	 bl OBJ_GetEntryOffset
 1854 018a 0346     	 mov r3,r0
 1855 018c FB85     	 strh r3,[r7,#46]
 1856              	.L123:
 922:../SSC/Src/objdef.c ****                 }
 923:../SSC/Src/objdef.c **** 
 924:../SSC/Src/objdef.c ****                 /* we increment the variable pointer to the corresponding word address */
 925:../SSC/Src/objdef.c ****                 pVarPtr += (bitOffset >> 4);
 1857              	 .loc 1 925 0
 1858 018e FB8D     	 ldrh r3,[r7,#46]
 1859 0190 1B09     	 lsrs r3,r3,#4
 1860 0192 9BB2     	 uxth r3,r3
 1861 0194 5B00     	 lsls r3,r3,#1
 1862 0196 7A69     	 ldr r2,[r7,#20]
 1863 0198 1344     	 add r3,r3,r2
 1864 019a 7B61     	 str r3,[r7,#20]
 926:../SSC/Src/objdef.c **** 
 927:../SSC/Src/objdef.c ****                 /* get the corresponding entry description */
 928:../SSC/Src/objdef.c ****                 pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
 1865              	 .loc 1 928 0
 1866 019c FB8E     	 ldrh r3,[r7,#54]
 1867 019e DBB2     	 uxtb r3,r3
 1868 01a0 7868     	 ldr r0,[r7,#4]
 1869 01a2 1946     	 mov r1,r3
 1870 01a4 FFF7FEFF 	 bl OBJ_GetEntryDesc
 1871 01a8 7862     	 str r0,[r7,#36]
 929:../SSC/Src/objdef.c **** 
 930:../SSC/Src/objdef.c ****                 if ( ((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) >= (nAlStatus & STATE_MASK) )
 1872              	 .loc 1 930 0
 1873 01aa 7B6A     	 ldr r3,[r7,#36]
 1874 01ac 9B88     	 ldrh r3,[r3,#4]
 1875 01ae DBB2     	 uxtb r3,r3
 1876 01b0 03F00703 	 and r3,r3,#7
 1877 01b4 DBB2     	 uxtb r3,r3
 1878 01b6 5B00     	 lsls r3,r3,#1
 1879 01b8 DBB2     	 uxtb r3,r3
 1880 01ba 1A46     	 mov r2,r3
 1881 01bc 574B     	 ldr r3,.L168
 1882 01be 1B78     	 ldrb r3,[r3]
 1883 01c0 03F00F03 	 and r3,r3,#15
 1884 01c4 9A42     	 cmp r2,r3
 1885 01c6 C0F29581 	 blt .L124
 931:../SSC/Src/objdef.c ****                 {
 932:../SSC/Src/objdef.c ****                     if ( i == subindex                                     /* requested entry */
 1886              	 .loc 1 932 0
 1887 01ca 7B7B     	 ldrb r3,[r7,#13]
 1888 01cc 9BB2     	 uxth r3,r3
 1889 01ce FA8E     	 ldrh r2,[r7,#54]
 1890 01d0 9A42     	 cmp r2,r3
 1891 01d2 0AD0     	 beq .L125
 933:../SSC/Src/objdef.c ****                         || (bCompleteAccess && i >= subindex) )       /* complete access and entry 
 1892              	 .loc 1 933 0
 1893 01d4 97F84C30 	 ldrb r3,[r7,#76]
 1894 01d8 002B     	 cmp r3,#0
 1895 01da 00F08A81 	 beq .L126
 1896              	 .loc 1 933 0 is_stmt 0 discriminator 1
 1897 01de 7B7B     	 ldrb r3,[r7,#13]
 1898 01e0 9BB2     	 uxth r3,r3
 1899 01e2 FA8E     	 ldrh r2,[r7,#54]
 1900 01e4 9A42     	 cmp r2,r3
 1901 01e6 C0F08481 	 bcc .L126
 1902              	.L125:
 1903              	.LBB13:
 934:../SSC/Src/objdef.c ****                     {
 935:../SSC/Src/objdef.c ****                         UINT16 bitMask;
 936:../SSC/Src/objdef.c **** 
 937:../SSC/Src/objdef.c ****                         /* we have to copy the entry */
 938:../SSC/Src/objdef.c ****                         if ( i == 0 && objCode != OBJCODE_VAR )
 1904              	 .loc 1 938 0 is_stmt 1
 1905 01ea FB8E     	 ldrh r3,[r7,#54]
 1906 01ec 002B     	 cmp r3,#0
 1907 01ee 0AD1     	 bne .L127
 1908              	 .loc 1 938 0 is_stmt 0 discriminator 1
 1909 01f0 97F82A30 	 ldrb r3,[r7,#42]
 1910 01f4 072B     	 cmp r3,#7
 1911 01f6 06D0     	 beq .L127
 939:../SSC/Src/objdef.c ****                         {
 940:../SSC/Src/objdef.c ****                             /* we read subindex 0 of an array or record */
 941:../SSC/Src/objdef.c ****                             {
 942:../SSC/Src/objdef.c ****                                 pData[0] = SWAPWORD((UINT16)maxSubindex);
 1912              	 .loc 1 942 0 is_stmt 1
 1913 01f8 BB6C     	 ldr r3,[r7,#72]
 1914 01fa BA8E     	 ldrh r2,[r7,#52]
 1915 01fc 1A80     	 strh r2,[r3]
 943:../SSC/Src/objdef.c ****                             }
 944:../SSC/Src/objdef.c **** 
 945:../SSC/Src/objdef.c ****                             /* we increment the destination pointer by 2 because the subindex 0 wil
 946:../SSC/Src/objdef.c ****                             transmitted as UINT16 for a complete access */
 947:../SSC/Src/objdef.c ****                             pData++;
 1916              	 .loc 1 947 0
 1917 01fe BB6C     	 ldr r3,[r7,#72]
 1918 0200 0233     	 adds r3,r3,#2
 1919 0202 BB64     	 str r3,[r7,#72]
 1920 0204 75E1     	 b .L126
 1921              	.L127:
 1922              	.LBB14:
 948:../SSC/Src/objdef.c ****                         }
 949:../SSC/Src/objdef.c ****                         else
 950:../SSC/Src/objdef.c ****                         {
 951:../SSC/Src/objdef.c ****                             UINT16 dataType = pEntry->DataType;
 1923              	 .loc 1 951 0
 1924 0206 7B6A     	 ldr r3,[r7,#36]
 1925 0208 1B88     	 ldrh r3,[r3]
 1926 020a BB85     	 strh r3,[r7,#44]
 952:../SSC/Src/objdef.c ****                             if (pEntry->DataType >= 0x700)
 1927              	 .loc 1 952 0
 1928 020c 7B6A     	 ldr r3,[r7,#36]
 1929 020e 1B88     	 ldrh r3,[r3]
 1930 0210 B3F5E06F 	 cmp r3,#1792
 1931 0214 15D3     	 bcc .L128
 953:../SSC/Src/objdef.c ****                             {
 954:../SSC/Src/objdef.c ****                                 /* the ENUM data types are defined from index 0x700 in this example
 955:../SSC/Src/objdef.c ****                                 convert in standard data type for the read access */
 956:../SSC/Src/objdef.c ****                                 if ( pEntry->BitLength <= 8 )
 1932              	 .loc 1 956 0
 1933 0216 7B6A     	 ldr r3,[r7,#36]
 1934 0218 5B88     	 ldrh r3,[r3,#2]
 1935 021a 082B     	 cmp r3,#8
 1936 021c 04D8     	 bhi .L129
 957:../SSC/Src/objdef.c ****                                     dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
 1937              	 .loc 1 957 0
 1938 021e 7B6A     	 ldr r3,[r7,#36]
 1939 0220 5B88     	 ldrh r3,[r3,#2]
 1940 0222 2F33     	 adds r3,r3,#47
 1941 0224 BB85     	 strh r3,[r7,#44]
 1942 0226 0CE0     	 b .L128
 1943              	.L129:
 958:../SSC/Src/objdef.c ****                                 else if ( pEntry->BitLength == 16 )
 1944              	 .loc 1 958 0
 1945 0228 7B6A     	 ldr r3,[r7,#36]
 1946 022a 5B88     	 ldrh r3,[r3,#2]
 1947 022c 102B     	 cmp r3,#16
 1948 022e 02D1     	 bne .L130
 959:../SSC/Src/objdef.c ****                                     dataType = DEFTYPE_UNSIGNED16;
 1949              	 .loc 1 959 0
 1950 0230 0623     	 movs r3,#6
 1951 0232 BB85     	 strh r3,[r7,#44]
 1952 0234 05E0     	 b .L128
 1953              	.L130:
 960:../SSC/Src/objdef.c ****                                 else if ( pEntry->BitLength == 32 )
 1954              	 .loc 1 960 0
 1955 0236 7B6A     	 ldr r3,[r7,#36]
 1956 0238 5B88     	 ldrh r3,[r3,#2]
 1957 023a 202B     	 cmp r3,#32
 1958 023c 01D1     	 bne .L128
 961:../SSC/Src/objdef.c ****                                     dataType = DEFTYPE_UNSIGNED32;
 1959              	 .loc 1 961 0
 1960 023e 0723     	 movs r3,#7
 1961 0240 BB85     	 strh r3,[r7,#44]
 1962              	.L128:
 962:../SSC/Src/objdef.c ****                             }
 963:../SSC/Src/objdef.c **** 
 964:../SSC/Src/objdef.c ****                             switch (dataType)
 1963              	 .loc 1 964 0
 1964 0242 BB8D     	 ldrh r3,[r7,#44]
 1965 0244 112B     	 cmp r3,#17
 1966 0246 00F0E080 	 beq .L132
 1967 024a 112B     	 cmp r3,#17
 1968 024c 1EDC     	 bgt .L133
 1969 024e 052B     	 cmp r3,#5
 1970 0250 66D0     	 beq .L134
 1971 0252 052B     	 cmp r3,#5
 1972 0254 0DDC     	 bgt .L135
 1973 0256 022B     	 cmp r3,#2
 1974 0258 04DC     	 bgt .L136
 1975 025a 012B     	 cmp r3,#1
 1976 025c 60DA     	 bge .L134
 1977 025e 002B     	 cmp r3,#0
 1978 0260 3AD0     	 beq .L137
 1979 0262 40E1     	 b .L131
 1980              	.L136:
 1981 0264 032B     	 cmp r3,#3
 1982 0266 00F0AD80 	 beq .L138
 1983 026a 042B     	 cmp r3,#4
 1984 026c 00F0B980 	 beq .L139
 1985 0270 39E1     	 b .L131
 1986              	.L135:
 1987 0272 082B     	 cmp r3,#8
 1988 0274 03DC     	 bgt .L140
 1989 0276 072B     	 cmp r3,#7
 1990 0278 80F2B380 	 bge .L139
 1991 027c A2E0     	 b .L138
 1992              	.L140:
 1993 027e 092B     	 cmp r3,#9
 1994 0280 00F00981 	 beq .L141
 1995 0284 0B2B     	 cmp r3,#11
 1996 0286 00F32E81 	 bgt .L131
 1997 028a DCE0     	 b .L142
 1998              	.L133:
 1999 028c 2D2B     	 cmp r3,#45
 2000 028e 47D0     	 beq .L134
 2001 0290 2D2B     	 cmp r3,#45
 2002 0292 11DC     	 bgt .L143
 2003 0294 1E2B     	 cmp r3,#30
 2004 0296 43D0     	 beq .L134
 2005 0298 1E2B     	 cmp r3,#30
 2006 029a 06DC     	 bgt .L144
 2007 029c 152B     	 cmp r3,#21
 2008 029e 00F0B480 	 beq .L132
 2009 02a2 1B2B     	 cmp r3,#27
 2010 02a4 00F0B180 	 beq .L132
 2011 02a8 1DE1     	 b .L131
 2012              	.L144:
 2013 02aa 1F2B     	 cmp r3,#31
 2014 02ac 00F08A80 	 beq .L138
 2015 02b0 202B     	 cmp r3,#32
 2016 02b2 00F09680 	 beq .L139
 2017 02b6 16E1     	 b .L131
 2018              	.L143:
 2019 02b8 372B     	 cmp r3,#55
 2020 02ba 07DC     	 bgt .L145
 2021 02bc 302B     	 cmp r3,#48
 2022 02be 2FDA     	 bge .L134
 2023 02c0 2E2B     	 cmp r3,#46
 2024 02c2 7FD0     	 beq .L138
 2025 02c4 2F2B     	 cmp r3,#47
 2026 02c6 00F08C80 	 beq .L139
 2027 02ca 0CE1     	 b .L131
 2028              	.L145:
 2029 02cc A3F51873 	 sub r3,r3,#608
 2030 02d0 032B     	 cmp r3,#3
 2031 02d2 00F20881 	 bhi .L131
 2032 02d6 B6E0     	 b .L142
 2033              	.L137:
 965:../SSC/Src/objdef.c ****                             {
 966:../SSC/Src/objdef.c ****                             case DEFTYPE_NULL:
 967:../SSC/Src/objdef.c ****                                 if(bCompleteAccess)
 2034              	 .loc 1 967 0
 2035 02d8 97F84C30 	 ldrb r3,[r7,#76]
 2036 02dc 002B     	 cmp r3,#0
 2037 02de 1AD0     	 beq .L146
 968:../SSC/Src/objdef.c ****                                 {
 969:../SSC/Src/objdef.c ****                                     /*Handle alignment entry*/
 970:../SSC/Src/objdef.c ****                                     if (((pEntry->BitLength & 0xF) > 0)
 2038              	 .loc 1 970 0
 2039 02e0 7B6A     	 ldr r3,[r7,#36]
 2040 02e2 5B88     	 ldrh r3,[r3,#2]
 2041 02e4 03F00F03 	 and r3,r3,#15
 2042 02e8 002B     	 cmp r3,#0
 2043 02ea 0ADD     	 ble .L147
 971:../SSC/Src/objdef.c ****                                         && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
 2044              	 .loc 1 971 0
 2045 02ec FB8D     	 ldrh r3,[r7,#46]
 2046 02ee 7A6A     	 ldr r2,[r7,#36]
 2047 02f0 5288     	 ldrh r2,[r2,#2]
 2048 02f2 1344     	 add r3,r3,r2
 2049 02f4 03F00F03 	 and r3,r3,#15
 2050 02f8 002B     	 cmp r3,#0
 2051 02fa 02D1     	 bne .L147
 972:../SSC/Src/objdef.c ****                                     {
 973:../SSC/Src/objdef.c ****                                         /* we have reached the UINT16 border */
 974:../SSC/Src/objdef.c ****                                         pData++;
 2052              	 .loc 1 974 0
 2053 02fc BB6C     	 ldr r3,[r7,#72]
 2054 02fe 0233     	 adds r3,r3,#2
 2055 0300 BB64     	 str r3,[r7,#72]
 2056              	.L147:
 975:../SSC/Src/objdef.c ****                                     }
 976:../SSC/Src/objdef.c **** 
 977:../SSC/Src/objdef.c ****                                     /*increment WORD offset*/
 978:../SSC/Src/objdef.c ****                                     pData += ((pEntry->BitLength & 0xF0) >> 4);
 2057              	 .loc 1 978 0
 2058 0302 7B6A     	 ldr r3,[r7,#36]
 2059 0304 5B88     	 ldrh r3,[r3,#2]
 2060 0306 03F0F003 	 and r3,r3,#240
 2061 030a 1B11     	 asrs r3,r3,#4
 2062 030c 5B00     	 lsls r3,r3,#1
 2063 030e BA6C     	 ldr r2,[r7,#72]
 2064 0310 1344     	 add r3,r3,r2
 2065 0312 BB64     	 str r3,[r7,#72]
 979:../SSC/Src/objdef.c ****                                 }
 980:../SSC/Src/objdef.c ****                                 else
 981:../SSC/Src/objdef.c ****                                 {
 982:../SSC/Src/objdef.c ****                                     return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
 983:../SSC/Src/objdef.c ****                                 }
 984:../SSC/Src/objdef.c ****                                 break;
 2066              	 .loc 1 984 0
 2067 0314 E9E0     	 b .L149
 2068              	.L146:
 982:../SSC/Src/objdef.c ****                                 }
 2069              	 .loc 1 982 0
 2070 0316 1823     	 movs r3,#24
 2071 0318 40E1     	 b .L115
 2072              	.L169:
 2073 031a 00BF     	 .align 2
 2074              	.L168:
 2075 031c 00000000 	 .word nAlStatus
 2076              	.L134:
 2077              	.LBB15:
 985:../SSC/Src/objdef.c ****                             case     DEFTYPE_BOOLEAN:
 986:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT1:
 987:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT2:
 988:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT3:
 989:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT4:
 990:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT5:
 991:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT6:
 992:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT7:
 993:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT8:
 994:../SSC/Src/objdef.c ****                             case     DEFTYPE_BITARR8:
 995:../SSC/Src/objdef.c ****                                 /* in this example the objects are defined in that way,
 996:../SSC/Src/objdef.c ****                                 that the bit types are always inside a 16-bit field,
 997:../SSC/Src/objdef.c ****                                 and they shall not overlap a byte border*/
 998:../SSC/Src/objdef.c ****                             case    DEFTYPE_INTEGER8:
 999:../SSC/Src/objdef.c ****                             case    DEFTYPE_UNSIGNED8:
1000:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO9*/
1001:../SSC/Src/objdef.c ****                             case    DEFTYPE_BYTE :
1002:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO9*/
1003:../SSC/Src/objdef.c ****                                 {
1004:../SSC/Src/objdef.c ****                                     /* depending on the bitOffset we have to copy the Hi or the Lo-
1005:../SSC/Src/objdef.c ****                                     UINT16 TmpValue = 0x0000;
 2078              	 .loc 1 1005 0
 2079 0320 0023     	 movs r3,#0
 2080 0322 7B82     	 strh r3,[r7,#18]
1006:../SSC/Src/objdef.c **** 
1007:../SSC/Src/objdef.c ****                                     bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
 2081              	 .loc 1 1007 0
 2082 0324 7B6A     	 ldr r3,[r7,#36]
 2083 0326 5B88     	 ldrh r3,[r3,#2]
 2084 0328 1A46     	 mov r2,r3
 2085 032a 9E4B     	 ldr r3,.L170
 2086 032c 33F81230 	 ldrh r3,[r3,r2,lsl#1]
 2087 0330 1A46     	 mov r2,r3
 2088 0332 FB8D     	 ldrh r3,[r7,#46]
 2089 0334 03F00F03 	 and r3,r3,#15
 2090 0338 02FA03F3 	 lsl r3,r2,r3
 2091 033c 3B82     	 strh r3,[r7,#16]
1008:../SSC/Src/objdef.c **** 
1009:../SSC/Src/objdef.c ****                                     /*Swap object data (if required); all masks and offsets are def
1010:../SSC/Src/objdef.c ****                                     TmpValue = SWAPWORD(pVarPtr[0]);
 2092              	 .loc 1 1010 0
 2093 033e 7B69     	 ldr r3,[r7,#20]
 2094 0340 1B88     	 ldrh r3,[r3]
 2095 0342 7B82     	 strh r3,[r7,#18]
1011:../SSC/Src/objdef.c **** 
1012:../SSC/Src/objdef.c ****                                     /*Clear pData if the first bits within the WORD memory will be 
1013:../SSC/Src/objdef.c ****                                     if ((bitOffset & 0x0F) == 0) 
 2096              	 .loc 1 1013 0
 2097 0344 FB8D     	 ldrh r3,[r7,#46]
 2098 0346 03F00F03 	 and r3,r3,#15
 2099 034a 002B     	 cmp r3,#0
 2100 034c 02D1     	 bne .L150
1014:../SSC/Src/objdef.c ****                                     {
1015:../SSC/Src/objdef.c ****                                         pData[0] = 0;
 2101              	 .loc 1 1015 0
 2102 034e BB6C     	 ldr r3,[r7,#72]
 2103 0350 0022     	 movs r2,#0
 2104 0352 1A80     	 strh r2,[r3]
 2105              	.L150:
1016:../SSC/Src/objdef.c ****                                     }
1017:../SSC/Src/objdef.c **** 
1018:../SSC/Src/objdef.c **** /* ECATCHANGE_START(V5.11) SDO7*/
1019:../SSC/Src/objdef.c ****                                     pData[0] = SWAPWORD(pData[0]);
 2106              	 .loc 1 1019 0
 2107 0354 BB6C     	 ldr r3,[r7,#72]
 2108 0356 1A88     	 ldrh r2,[r3]
 2109 0358 BB6C     	 ldr r3,[r7,#72]
 2110 035a 1A80     	 strh r2,[r3]
1020:../SSC/Src/objdef.c **** 
1021:../SSC/Src/objdef.c ****                                     if (bCompleteAccess) 
 2111              	 .loc 1 1021 0
 2112 035c 97F84C30 	 ldrb r3,[r7,#76]
 2113 0360 002B     	 cmp r3,#0
 2114 0362 0AD0     	 beq .L151
1022:../SSC/Src/objdef.c ****                                     {
1023:../SSC/Src/objdef.c ****                                         /*shifting is not required for Complete access because the 
1024:../SSC/Src/objdef.c ****                                         pData[0] |= TmpValue & bitMask;
 2115              	 .loc 1 1024 0
 2116 0364 BB6C     	 ldr r3,[r7,#72]
 2117 0366 1A88     	 ldrh r2,[r3]
 2118 0368 798A     	 ldrh r1,[r7,#18]
 2119 036a 3B8A     	 ldrh r3,[r7,#16]
 2120 036c 0B40     	 ands r3,r3,r1
 2121 036e 9BB2     	 uxth r3,r3
 2122 0370 1343     	 orrs r3,r3,r2
 2123 0372 9AB2     	 uxth r2,r3
 2124 0374 BB6C     	 ldr r3,[r7,#72]
 2125 0376 1A80     	 strh r2,[r3]
 2126 0378 13E0     	 b .L152
 2127              	.L151:
1025:../SSC/Src/objdef.c ****                                     }
1026:../SSC/Src/objdef.c ****                                     else
1027:../SSC/Src/objdef.c ****                                     {
1028:../SSC/Src/objdef.c ****                                         /*Shift Bits to the beginning of the mailbox memory*/
1029:../SSC/Src/objdef.c ****                                         pData[0] |= ((TmpValue & bitMask) >> (bitOffset & 0x0F));
 2128              	 .loc 1 1029 0
 2129 037a BB6C     	 ldr r3,[r7,#72]
 2130 037c 1B88     	 ldrh r3,[r3]
 2131 037e 99B2     	 uxth r1,r3
 2132 0380 7A8A     	 ldrh r2,[r7,#18]
 2133 0382 3B8A     	 ldrh r3,[r7,#16]
 2134 0384 1340     	 ands r3,r3,r2
 2135 0386 9BB2     	 uxth r3,r3
 2136 0388 1A46     	 mov r2,r3
 2137 038a FB8D     	 ldrh r3,[r7,#46]
 2138 038c 03F00F03 	 and r3,r3,#15
 2139 0390 42FA03F3 	 asr r3,r2,r3
 2140 0394 9BB2     	 uxth r3,r3
 2141 0396 0A46     	 mov r2,r1
 2142 0398 1343     	 orrs r3,r3,r2
 2143 039a 9BB2     	 uxth r3,r3
 2144 039c 9AB2     	 uxth r2,r3
 2145 039e BB6C     	 ldr r3,[r7,#72]
 2146 03a0 1A80     	 strh r2,[r3]
 2147              	.L152:
1030:../SSC/Src/objdef.c ****                                     }
1031:../SSC/Src/objdef.c **** 
1032:../SSC/Src/objdef.c ****                                     pData[0] = SWAPWORD(pData[0]);
 2148              	 .loc 1 1032 0
 2149 03a2 BB6C     	 ldr r3,[r7,#72]
 2150 03a4 1A88     	 ldrh r2,[r3]
 2151 03a6 BB6C     	 ldr r3,[r7,#72]
 2152 03a8 1A80     	 strh r2,[r3]
1033:../SSC/Src/objdef.c **** /* ECATCHANGE_END(V5.11) SDO7*/
1034:../SSC/Src/objdef.c ****                                     if ( ((bitOffset + pEntry->BitLength) & 0x0F) == 0 )
 2153              	 .loc 1 1034 0
 2154 03aa FB8D     	 ldrh r3,[r7,#46]
 2155 03ac 7A6A     	 ldr r2,[r7,#36]
 2156 03ae 5288     	 ldrh r2,[r2,#2]
 2157 03b0 1344     	 add r3,r3,r2
 2158 03b2 03F00F03 	 and r3,r3,#15
 2159 03b6 002B     	 cmp r3,#0
 2160 03b8 03D1     	 bne .L153
1035:../SSC/Src/objdef.c ****                                     {
1036:../SSC/Src/objdef.c ****                                         /* we have reached the UINT16 border */
1037:../SSC/Src/objdef.c ****                                         pData++;
 2161              	 .loc 1 1037 0
 2162 03ba BB6C     	 ldr r3,[r7,#72]
 2163 03bc 0233     	 adds r3,r3,#2
 2164 03be BB64     	 str r3,[r7,#72]
 2165              	.LBE15:
1038:../SSC/Src/objdef.c ****                                     }
1039:../SSC/Src/objdef.c **** 
1040:../SSC/Src/objdef.c ****                                 }
1041:../SSC/Src/objdef.c ****                                 break;
 2166              	 .loc 1 1041 0
 2167 03c0 93E0     	 b .L149
 2168              	.L153:
 2169 03c2 92E0     	 b .L149
 2170              	.L138:
1042:../SSC/Src/objdef.c ****                             case    DEFTYPE_INTEGER16:
1043:../SSC/Src/objdef.c ****                             case    DEFTYPE_UNSIGNED16:
1044:../SSC/Src/objdef.c ****                             case    DEFTYPE_BITARR16:
1045:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO9*/
1046:../SSC/Src/objdef.c ****                             case    DEFTYPE_WORD:
1047:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO9*/
1048:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO1*/
1049:../SSC/Src/objdef.c ****                                 if(bitOffset & 0xF)
 2171              	 .loc 1 1049 0
 2172 03c4 FB8D     	 ldrh r3,[r7,#46]
 2173 03c6 03F00F03 	 and r3,r3,#15
 2174 03ca 002B     	 cmp r3,#0
 2175 03cc 01D0     	 beq .L154
1050:../SSC/Src/objdef.c ****                                 {
1051:../SSC/Src/objdef.c ****                                     /* return an error in case of an odd word offset (to support 16
1052:../SSC/Src/objdef.c ****                                     return ABORTIDX_UNSUPPORTED_ACCESS;
 2176              	 .loc 1 1052 0
 2177 03ce 0523     	 movs r3,#5
 2178 03d0 E4E0     	 b .L115
 2179              	.L154:
1053:../SSC/Src/objdef.c ****                                 }
1054:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO1*/
1055:../SSC/Src/objdef.c ****                                 /* in this example the objects are defined in that way,
1056:../SSC/Src/objdef.c ****                                 that the 16 bit type are always starting at an exact WORD offset */
1057:../SSC/Src/objdef.c ****                                 pData[0] = SWAPWORD(pVarPtr[0]);
 2180              	 .loc 1 1057 0
 2181 03d2 7B69     	 ldr r3,[r7,#20]
 2182 03d4 1A88     	 ldrh r2,[r3]
 2183 03d6 BB6C     	 ldr r3,[r7,#72]
 2184 03d8 1A80     	 strh r2,[r3]
1058:../SSC/Src/objdef.c ****                                 pData++;
 2185              	 .loc 1 1058 0
 2186 03da BB6C     	 ldr r3,[r7,#72]
 2187 03dc 0233     	 adds r3,r3,#2
 2188 03de BB64     	 str r3,[r7,#72]
1059:../SSC/Src/objdef.c ****                                 break;
 2189              	 .loc 1 1059 0
 2190 03e0 83E0     	 b .L149
 2191              	.L139:
1060:../SSC/Src/objdef.c ****                             case    DEFTYPE_UNSIGNED32:
1061:../SSC/Src/objdef.c ****                             case    DEFTYPE_INTEGER32:
1062:../SSC/Src/objdef.c ****                             case    DEFTYPE_REAL32:
1063:../SSC/Src/objdef.c ****                             case    DEFTYPE_BITARR32:
1064:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO9*/
1065:../SSC/Src/objdef.c ****                             case    DEFTYPE_DWORD:
1066:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO9*/
1067:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO1*/
1068:../SSC/Src/objdef.c ****                                 if(bitOffset & 0xF)
 2192              	 .loc 1 1068 0
 2193 03e2 FB8D     	 ldrh r3,[r7,#46]
 2194 03e4 03F00F03 	 and r3,r3,#15
 2195 03e8 002B     	 cmp r3,#0
 2196 03ea 01D0     	 beq .L155
1069:../SSC/Src/objdef.c ****                                 {
1070:../SSC/Src/objdef.c ****                                     /* return an error in case of an odd word offset (to support 16
1071:../SSC/Src/objdef.c ****                                     return ABORTIDX_UNSUPPORTED_ACCESS;
 2197              	 .loc 1 1071 0
 2198 03ec 0523     	 movs r3,#5
 2199 03ee D5E0     	 b .L115
 2200              	.L155:
1072:../SSC/Src/objdef.c ****                                 }
1073:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO1*/
1074:../SSC/Src/objdef.c **** 
1075:../SSC/Src/objdef.c ****                                 /* in this example the objects are defined in that way,
1076:../SSC/Src/objdef.c ****                                 that the 32 bit type are always starting at an exact WORD offset */
1077:../SSC/Src/objdef.c ****                                 pData[0] = pVarPtr[0];
 2201              	 .loc 1 1077 0
 2202 03f0 7B69     	 ldr r3,[r7,#20]
 2203 03f2 1A88     	 ldrh r2,[r3]
 2204 03f4 BB6C     	 ldr r3,[r7,#72]
 2205 03f6 1A80     	 strh r2,[r3]
1078:../SSC/Src/objdef.c ****                                 pData[1] = pVarPtr[1];
 2206              	 .loc 1 1078 0
 2207 03f8 BB6C     	 ldr r3,[r7,#72]
 2208 03fa 0233     	 adds r3,r3,#2
 2209 03fc 7A69     	 ldr r2,[r7,#20]
 2210 03fe 5288     	 ldrh r2,[r2,#2]
 2211 0400 1A80     	 strh r2,[r3]
1079:../SSC/Src/objdef.c ****                                 pData += 2;
 2212              	 .loc 1 1079 0
 2213 0402 BB6C     	 ldr r3,[r7,#72]
 2214 0404 0433     	 adds r3,r3,#4
 2215 0406 BB64     	 str r3,[r7,#72]
1080:../SSC/Src/objdef.c ****                                 break;
 2216              	 .loc 1 1080 0
 2217 0408 6FE0     	 b .L149
 2218              	.L132:
1081:../SSC/Src/objdef.c ****                             case    DEFTYPE_REAL64:
1082:../SSC/Src/objdef.c ****                             case 	DEFTYPE_INTEGER64:
1083:../SSC/Src/objdef.c ****                             case    DEFTYPE_UNSIGNED64:
1084:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO1*/
1085:../SSC/Src/objdef.c ****                                 if(bitOffset & 0xF)
 2219              	 .loc 1 1085 0
 2220 040a FB8D     	 ldrh r3,[r7,#46]
 2221 040c 03F00F03 	 and r3,r3,#15
 2222 0410 002B     	 cmp r3,#0
 2223 0412 01D0     	 beq .L156
1086:../SSC/Src/objdef.c ****                                 {
1087:../SSC/Src/objdef.c ****                                     /* return an error in case of an odd word offset (to support 16
1088:../SSC/Src/objdef.c ****                                     return ABORTIDX_UNSUPPORTED_ACCESS;
 2224              	 .loc 1 1088 0
 2225 0414 0523     	 movs r3,#5
 2226 0416 C1E0     	 b .L115
 2227              	.L156:
1089:../SSC/Src/objdef.c ****                                 }
1090:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO1*/
1091:../SSC/Src/objdef.c **** 
1092:../SSC/Src/objdef.c ****                                 /* in this example the objects are defined in that way,
1093:../SSC/Src/objdef.c ****                                 that the 64 bit type are always starting at an exact WORD offset */
1094:../SSC/Src/objdef.c ****                                 pData[0] = pVarPtr[0];
 2228              	 .loc 1 1094 0
 2229 0418 7B69     	 ldr r3,[r7,#20]
 2230 041a 1A88     	 ldrh r2,[r3]
 2231 041c BB6C     	 ldr r3,[r7,#72]
 2232 041e 1A80     	 strh r2,[r3]
1095:../SSC/Src/objdef.c ****                                 pData[1] = pVarPtr[1];
 2233              	 .loc 1 1095 0
 2234 0420 BB6C     	 ldr r3,[r7,#72]
 2235 0422 0233     	 adds r3,r3,#2
 2236 0424 7A69     	 ldr r2,[r7,#20]
 2237 0426 5288     	 ldrh r2,[r2,#2]
 2238 0428 1A80     	 strh r2,[r3]
1096:../SSC/Src/objdef.c ****                                 pData[2] = pVarPtr[2];
 2239              	 .loc 1 1096 0
 2240 042a BB6C     	 ldr r3,[r7,#72]
 2241 042c 0433     	 adds r3,r3,#4
 2242 042e 7A69     	 ldr r2,[r7,#20]
 2243 0430 9288     	 ldrh r2,[r2,#4]
 2244 0432 1A80     	 strh r2,[r3]
1097:../SSC/Src/objdef.c ****                                 pData[3] = pVarPtr[3];
 2245              	 .loc 1 1097 0
 2246 0434 BB6C     	 ldr r3,[r7,#72]
 2247 0436 0633     	 adds r3,r3,#6
 2248 0438 7A69     	 ldr r2,[r7,#20]
 2249 043a D288     	 ldrh r2,[r2,#6]
 2250 043c 1A80     	 strh r2,[r3]
1098:../SSC/Src/objdef.c ****                                 pData += 4;
 2251              	 .loc 1 1098 0
 2252 043e BB6C     	 ldr r3,[r7,#72]
 2253 0440 0833     	 adds r3,r3,#8
 2254 0442 BB64     	 str r3,[r7,#72]
1099:../SSC/Src/objdef.c ****                                 break;
 2255              	 .loc 1 1099 0
 2256 0444 51E0     	 b .L149
 2257              	.L142:
1100:../SSC/Src/objdef.c ****                             case    DEFTYPE_OCTETSTRING:
1101:../SSC/Src/objdef.c ****                             case    DEFTYPE_UNICODE_STRING:
1102:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO9*/
1103:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_INT :
1104:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_SINT :
1105:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_DINT :
1106:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_UDINT:
1107:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO9*/
1108:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO1*/
1109:../SSC/Src/objdef.c ****                                 if(bitOffset & 0xF)
 2258              	 .loc 1 1109 0
 2259 0446 FB8D     	 ldrh r3,[r7,#46]
 2260 0448 03F00F03 	 and r3,r3,#15
 2261 044c 002B     	 cmp r3,#0
 2262 044e 01D0     	 beq .L157
1110:../SSC/Src/objdef.c ****                                 {
1111:../SSC/Src/objdef.c ****                                     /* return an error in case of an odd word offset (to support 16
1112:../SSC/Src/objdef.c ****                                     return ABORTIDX_UNSUPPORTED_ACCESS;
 2263              	 .loc 1 1112 0
 2264 0450 0523     	 movs r3,#5
 2265 0452 A3E0     	 b .L115
 2266              	.L157:
1113:../SSC/Src/objdef.c ****                                 }
1114:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO1*/
1115:../SSC/Src/objdef.c **** 
1116:../SSC/Src/objdef.c ****                                 OBJTOMBXMEMCPY(pData, pVarPtr, BIT2BYTE(pEntry->BitLength));
 2267              	 .loc 1 1116 0
 2268 0454 7B6A     	 ldr r3,[r7,#36]
 2269 0456 5B88     	 ldrh r3,[r3,#2]
 2270 0458 0733     	 adds r3,r3,#7
 2271 045a DB10     	 asrs r3,r3,#3
 2272 045c B86C     	 ldr r0,[r7,#72]
 2273 045e 7969     	 ldr r1,[r7,#20]
 2274 0460 1A46     	 mov r2,r3
 2275 0462 FFF7FEFF 	 bl memcpy
1117:../SSC/Src/objdef.c **** 
1118:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO2*/
1119:../SSC/Src/objdef.c ****                                 pData += BIT2WORD((pEntry->BitLength & ~0xF));
 2276              	 .loc 1 1119 0
 2277 0466 7B6A     	 ldr r3,[r7,#36]
 2278 0468 5B88     	 ldrh r3,[r3,#2]
 2279 046a 23F00F03 	 bic r3,r3,#15
 2280 046e 0F33     	 adds r3,r3,#15
 2281 0470 1B11     	 asrs r3,r3,#4
 2282 0472 5B00     	 lsls r3,r3,#1
 2283 0474 BA6C     	 ldr r2,[r7,#72]
 2284 0476 1344     	 add r3,r3,r2
 2285 0478 BB64     	 str r3,[r7,#72]
1120:../SSC/Src/objdef.c ****                                 
1121:../SSC/Src/objdef.c ****                                 if((pEntry->BitLength & 0xF) != 0)
 2286              	 .loc 1 1121 0
 2287 047a 7B6A     	 ldr r3,[r7,#36]
 2288 047c 5B88     	 ldrh r3,[r3,#2]
 2289 047e 03F00F03 	 and r3,r3,#15
 2290 0482 002B     	 cmp r3,#0
 2291 0484 06D0     	 beq .L158
1122:../SSC/Src/objdef.c ****                                 {
1123:../SSC/Src/objdef.c ****                                     /*current entry has an odd word length => clear last byte of ne
1124:../SSC/Src/objdef.c ****                                     *pData &= 0xFF;
 2292              	 .loc 1 1124 0
 2293 0486 BB6C     	 ldr r3,[r7,#72]
 2294 0488 1B88     	 ldrh r3,[r3]
 2295 048a DBB2     	 uxtb r3,r3
 2296 048c 9AB2     	 uxth r2,r3
 2297 048e BB6C     	 ldr r3,[r7,#72]
 2298 0490 1A80     	 strh r2,[r3]
1125:../SSC/Src/objdef.c ****                                 }
1126:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO2*/
1127:../SSC/Src/objdef.c **** 
1128:../SSC/Src/objdef.c ****                                 break;
 2299              	 .loc 1 1128 0
 2300 0492 2AE0     	 b .L149
 2301              	.L158:
 2302 0494 29E0     	 b .L149
 2303              	.L141:
1129:../SSC/Src/objdef.c ****                             case    DEFTYPE_VISIBLESTRING:
1130:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO1*/
1131:../SSC/Src/objdef.c ****                                 if(bitOffset & 0xF)
 2304              	 .loc 1 1131 0
 2305 0496 FB8D     	 ldrh r3,[r7,#46]
 2306 0498 03F00F03 	 and r3,r3,#15
 2307 049c 002B     	 cmp r3,#0
 2308 049e 01D0     	 beq .L159
1132:../SSC/Src/objdef.c ****                                 {
1133:../SSC/Src/objdef.c ****                                     /* return an error in case of an odd word offset (to support 16
1134:../SSC/Src/objdef.c ****                                     return ABORTIDX_UNSUPPORTED_ACCESS;
 2309              	 .loc 1 1134 0
 2310 04a0 0523     	 movs r3,#5
 2311 04a2 7BE0     	 b .L115
 2312              	.L159:
1135:../SSC/Src/objdef.c ****                                 }
1136:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO1*/
1137:../SSC/Src/objdef.c **** 
1138:../SSC/Src/objdef.c ****                                 /* in this example the objects are defined in that way,
1139:../SSC/Src/objdef.c ****                                 that these types are always starting at an even WORD offset */
1140:../SSC/Src/objdef.c ****                                 OBJTOMBXSTRCPY(pData, pVarPtr, BIT2BYTE(pEntry->BitLength));
 2313              	 .loc 1 1140 0
 2314 04a4 7B6A     	 ldr r3,[r7,#36]
 2315 04a6 5B88     	 ldrh r3,[r3,#2]
 2316 04a8 0733     	 adds r3,r3,#7
 2317 04aa DB10     	 asrs r3,r3,#3
 2318 04ac B86C     	 ldr r0,[r7,#72]
 2319 04ae 7969     	 ldr r1,[r7,#20]
 2320 04b0 1A46     	 mov r2,r3
 2321 04b2 FFF7FEFF 	 bl memcpy
1141:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO2*/
1142:../SSC/Src/objdef.c ****                                 pData += BIT2WORD((pEntry->BitLength & ~0xF));
 2322              	 .loc 1 1142 0
 2323 04b6 7B6A     	 ldr r3,[r7,#36]
 2324 04b8 5B88     	 ldrh r3,[r3,#2]
 2325 04ba 23F00F03 	 bic r3,r3,#15
 2326 04be 0F33     	 adds r3,r3,#15
 2327 04c0 1B11     	 asrs r3,r3,#4
 2328 04c2 5B00     	 lsls r3,r3,#1
 2329 04c4 BA6C     	 ldr r2,[r7,#72]
 2330 04c6 1344     	 add r3,r3,r2
 2331 04c8 BB64     	 str r3,[r7,#72]
1143:../SSC/Src/objdef.c **** 
1144:../SSC/Src/objdef.c ****                                 if((pEntry->BitLength & 0xF) != 0)
 2332              	 .loc 1 1144 0
 2333 04ca 7B6A     	 ldr r3,[r7,#36]
 2334 04cc 5B88     	 ldrh r3,[r3,#2]
 2335 04ce 03F00F03 	 and r3,r3,#15
 2336 04d2 002B     	 cmp r3,#0
 2337 04d4 06D0     	 beq .L160
1145:../SSC/Src/objdef.c ****                                 {
1146:../SSC/Src/objdef.c ****                                     /*current entry has an odd word length => clear last byte of ne
1147:../SSC/Src/objdef.c ****                                     *pData &= 0xFF;
 2338              	 .loc 1 1147 0
 2339 04d6 BB6C     	 ldr r3,[r7,#72]
 2340 04d8 1B88     	 ldrh r3,[r3]
 2341 04da DBB2     	 uxtb r3,r3
 2342 04dc 9AB2     	 uxth r2,r3
 2343 04de BB6C     	 ldr r3,[r7,#72]
 2344 04e0 1A80     	 strh r2,[r3]
1148:../SSC/Src/objdef.c ****                                 }
1149:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO2*/
1150:../SSC/Src/objdef.c ****                                 
1151:../SSC/Src/objdef.c ****                                 break;
 2345              	 .loc 1 1151 0
 2346 04e2 02E0     	 b .L149
 2347              	.L160:
 2348 04e4 01E0     	 b .L149
 2349              	.L131:
1152:../SSC/Src/objdef.c ****                             default:
1153:../SSC/Src/objdef.c ****                                 /* other data types are not supported from this example */
1154:../SSC/Src/objdef.c ****                                 return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
 2350              	 .loc 1 1154 0
 2351 04e6 1823     	 movs r3,#24
 2352 04e8 58E0     	 b .L115
 2353              	.L149:
1155:../SSC/Src/objdef.c ****                             } //switch (deftype)
1156:../SSC/Src/objdef.c **** 
1157:../SSC/Src/objdef.c ****                             bRead = 1;
 2354              	 .loc 1 1157 0
 2355 04ea 0123     	 movs r3,#1
 2356 04ec 87F83130 	 strb r3,[r7,#49]
 2357              	.LBE14:
 2358              	.LBE13:
 2359 04f0 44E0     	 b .L161
 2360              	.L126:
 2361 04f2 43E0     	 b .L161
 2362              	.L124:
 2363              	.LBB16:
1158:../SSC/Src/objdef.c ****                         }
1159:../SSC/Src/objdef.c ****                     }
1160:../SSC/Src/objdef.c ****                 }
1161:../SSC/Src/objdef.c ****                 else
1162:../SSC/Src/objdef.c ****                 {
1163:../SSC/Src/objdef.c ****                     /*No access to current object entry => shift pData if required*/
1164:../SSC/Src/objdef.c ****                     UINT8 cnt = 0;
 2364              	 .loc 1 1164 0
 2365 04f4 0023     	 movs r3,#0
 2366 04f6 87F82B30 	 strb r3,[r7,#43]
1165:../SSC/Src/objdef.c **** 
1166:../SSC/Src/objdef.c ****                     /*If this entry is the first in the 16Bit block clear the memory*/
1167:../SSC/Src/objdef.c ****                     if ((bitOffset & 0x0F) == 0) 
 2367              	 .loc 1 1167 0
 2368 04fa FB8D     	 ldrh r3,[r7,#46]
 2369 04fc 03F00F03 	 and r3,r3,#15
 2370 0500 002B     	 cmp r3,#0
 2371 0502 02D1     	 bne .L162
1168:../SSC/Src/objdef.c ****                     {
1169:../SSC/Src/objdef.c ****                         *pData = 0;
 2372              	 .loc 1 1169 0
 2373 0504 BB6C     	 ldr r3,[r7,#72]
 2374 0506 0022     	 movs r2,#0
 2375 0508 1A80     	 strh r2,[r3]
 2376              	.L162:
1170:../SSC/Src/objdef.c ****                     }
1171:../SSC/Src/objdef.c **** 
1172:../SSC/Src/objdef.c ****                     /*Handle Bit/Byte Offset*/
1173:../SSC/Src/objdef.c ****                     if (((pEntry->BitLength & 0xF) > 0)
 2377              	 .loc 1 1173 0
 2378 050a 7B6A     	 ldr r3,[r7,#36]
 2379 050c 5B88     	 ldrh r3,[r3,#2]
 2380 050e 03F00F03 	 and r3,r3,#15
 2381 0512 002B     	 cmp r3,#0
 2382 0514 0DDD     	 ble .L163
1174:../SSC/Src/objdef.c ****                         && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
 2383              	 .loc 1 1174 0
 2384 0516 FB8D     	 ldrh r3,[r7,#46]
 2385 0518 7A6A     	 ldr r2,[r7,#36]
 2386 051a 5288     	 ldrh r2,[r2,#2]
 2387 051c 1344     	 add r3,r3,r2
 2388 051e 03F00F03 	 and r3,r3,#15
 2389 0522 002B     	 cmp r3,#0
 2390 0524 05D1     	 bne .L163
1175:../SSC/Src/objdef.c ****                     {
1176:../SSC/Src/objdef.c ****                         /* we have reached the UINT16 border */
1177:../SSC/Src/objdef.c ****                         pData++;
 2391              	 .loc 1 1177 0
 2392 0526 BB6C     	 ldr r3,[r7,#72]
 2393 0528 0233     	 adds r3,r3,#2
 2394 052a BB64     	 str r3,[r7,#72]
1178:../SSC/Src/objdef.c ****                         
1179:../SSC/Src/objdef.c ****                         /*Clear new buffer*/
1180:../SSC/Src/objdef.c ****                         *pData = 0;
 2395              	 .loc 1 1180 0
 2396 052c BB6C     	 ldr r3,[r7,#72]
 2397 052e 0022     	 movs r2,#0
 2398 0530 1A80     	 strh r2,[r3]
 2399              	.L163:
1181:../SSC/Src/objdef.c ****                     }
1182:../SSC/Src/objdef.c **** 
1183:../SSC/Src/objdef.c ****                     /*increment WORD offset*/
1184:../SSC/Src/objdef.c ****                     for(cnt = 0; cnt <((pEntry->BitLength & 0xF0) >> 4); cnt++)
 2400              	 .loc 1 1184 0
 2401 0532 0023     	 movs r3,#0
 2402 0534 87F82B30 	 strb r3,[r7,#43]
 2403 0538 0AE0     	 b .L164
 2404              	.L165:
1185:../SSC/Src/objdef.c ****                     {
1186:../SSC/Src/objdef.c ****                         /*current 16Bit are skipped => clear current buffer */
1187:../SSC/Src/objdef.c ****                         pData++;
 2405              	 .loc 1 1187 0 discriminator 3
 2406 053a BB6C     	 ldr r3,[r7,#72]
 2407 053c 0233     	 adds r3,r3,#2
 2408 053e BB64     	 str r3,[r7,#72]
1188:../SSC/Src/objdef.c **** 
1189:../SSC/Src/objdef.c ****                         /*Clear new buffer*/
1190:../SSC/Src/objdef.c ****                         *pData = 0;
 2409              	 .loc 1 1190 0 discriminator 3
 2410 0540 BB6C     	 ldr r3,[r7,#72]
 2411 0542 0022     	 movs r2,#0
 2412 0544 1A80     	 strh r2,[r3]
1184:../SSC/Src/objdef.c ****                     {
 2413              	 .loc 1 1184 0 discriminator 3
 2414 0546 97F82B30 	 ldrb r3,[r7,#43]
 2415 054a 0133     	 adds r3,r3,#1
 2416 054c 87F82B30 	 strb r3,[r7,#43]
 2417              	.L164:
1184:../SSC/Src/objdef.c ****                     {
 2418              	 .loc 1 1184 0 is_stmt 0 discriminator 1
 2419 0550 97F82B20 	 ldrb r2,[r7,#43]
 2420 0554 7B6A     	 ldr r3,[r7,#36]
 2421 0556 5B88     	 ldrh r3,[r3,#2]
 2422 0558 03F0F003 	 and r3,r3,#240
 2423 055c 1B11     	 asrs r3,r3,#4
 2424 055e 9A42     	 cmp r2,r3
 2425 0560 EBDB     	 blt .L165
1191:../SSC/Src/objdef.c ****                     }
1192:../SSC/Src/objdef.c **** 
1193:../SSC/Src/objdef.c **** 
1194:../SSC/Src/objdef.c ****                     
1195:../SSC/Src/objdef.c **** 
1196:../SSC/Src/objdef.c ****                     /* we don't have read access */
1197:../SSC/Src/objdef.c ****                     if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
 2426              	 .loc 1 1197 0 is_stmt 1
 2427 0562 7B6A     	 ldr r3,[r7,#36]
 2428 0564 9B88     	 ldrh r3,[r3,#4]
 2429 0566 03F00703 	 and r3,r3,#7
 2430 056a 002B     	 cmp r3,#0
 2431 056c 03D1     	 bne .L166
1198:../SSC/Src/objdef.c ****                     {
1199:../SSC/Src/objdef.c ****                         /* it is a write only entry */
1200:../SSC/Src/objdef.c ****                         result = ABORTIDX_WRITE_ONLY_ENTRY;
 2432              	 .loc 1 1200 0
 2433 056e 0623     	 movs r3,#6
 2434 0570 87F83030 	 strb r3,[r7,#48]
 2435 0574 02E0     	 b .L161
 2436              	.L166:
1201:../SSC/Src/objdef.c ****                     }
1202:../SSC/Src/objdef.c ****                     else
1203:../SSC/Src/objdef.c ****                     {
1204:../SSC/Src/objdef.c ****                         /* we don't have read access in this state */
1205:../SSC/Src/objdef.c ****                         result = ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
 2437              	 .loc 1 1205 0
 2438 0576 1A23     	 movs r3,#26
 2439 0578 87F83030 	 strb r3,[r7,#48]
 2440              	.L161:
 2441              	.LBE16:
 2442              	.LBE12:
 908:../SSC/Src/objdef.c ****             {
 2443              	 .loc 1 908 0 discriminator 2
 2444 057c FB8E     	 ldrh r3,[r7,#54]
 2445 057e 0133     	 adds r3,r3,#1
 2446 0580 FB86     	 strh r3,[r7,#54]
 2447              	.L122:
 908:../SSC/Src/objdef.c ****             {
 2448              	 .loc 1 908 0 is_stmt 0 discriminator 1
 2449 0582 FA8E     	 ldrh r2,[r7,#54]
 2450 0584 7B8E     	 ldrh r3,[r7,#50]
 2451 0586 9A42     	 cmp r2,r3
 2452 0588 7FF6EDAD 	 bls .L167
1206:../SSC/Src/objdef.c ****                     }
1207:../SSC/Src/objdef.c ****                 }
1208:../SSC/Src/objdef.c ****             }
1209:../SSC/Src/objdef.c **** 
1210:../SSC/Src/objdef.c ****             if(bRead == 0)
 2453              	 .loc 1 1210 0 is_stmt 1
 2454 058c 97F83130 	 ldrb r3,[r7,#49]
 2455 0590 002B     	 cmp r3,#0
 2456 0592 02D1     	 bne .L121
1211:../SSC/Src/objdef.c ****                 return result;
 2457              	 .loc 1 1211 0
 2458 0594 97F83030 	 ldrb r3,[r7,#48]
 2459 0598 00E0     	 b .L115
 2460              	.L121:
 2461              	.LBE11:
1212:../SSC/Src/objdef.c ****         }
1213:../SSC/Src/objdef.c **** 
1214:../SSC/Src/objdef.c ****     return 0;
 2462              	 .loc 1 1214 0
 2463 059a 0023     	 movs r3,#0
 2464              	.L115:
1215:../SSC/Src/objdef.c **** }
 2465              	 .loc 1 1215 0
 2466 059c 1846     	 mov r0,r3
 2467 059e 3C37     	 adds r7,r7,#60
 2468              	.LCFI59:
 2469              	 .cfi_def_cfa_offset 12
 2470 05a0 BD46     	 mov sp,r7
 2471              	.LCFI60:
 2472              	 .cfi_def_cfa_register 13
 2473              	 
 2474 05a2 90BD     	 pop {r4,r7,pc}
 2475              	.L171:
 2476              	 .align 2
 2477              	.L170:
 2478 05a4 00000000 	 .word cBitMask
 2479              	 .cfi_endproc
 2480              	.LFE182:
 2482              	 .section .text.OBJ_Write,"ax",%progbits
 2483              	 .align 2
 2484              	 .global OBJ_Write
 2485              	 .thumb
 2486              	 .thumb_func
 2488              	OBJ_Write:
 2489              	.LFB183:
1216:../SSC/Src/objdef.c **** 
1217:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
1218:../SSC/Src/objdef.c **** /**
1219:../SSC/Src/objdef.c ****  \param     index                 index of the requested object.
1220:../SSC/Src/objdef.c ****  \param     subindex                subindex of the requested object.
1221:../SSC/Src/objdef.c ****  \param    dataSize                received data size of the SDO Download
1222:../SSC/Src/objdef.c ****  \param     pObjEntry            handle to the dictionary object returned by
1223:../SSC/Src/objdef.c ****                                      OBJ_GetObjectHandle which was called before
1224:../SSC/Src/objdef.c ****  \param    pData                    Pointer to the buffer where the written data can be copied from
1225:../SSC/Src/objdef.c ****  \param    bCompleteAccess    Indicates if a complete write of all subindices of the
1226:../SSC/Src/objdef.c ****                                      object shall be done or not
1227:../SSC/Src/objdef.c **** 
1228:../SSC/Src/objdef.c ****  \return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
1229:../SSC/Src/objdef.c ****             sdosrv.h))
1230:../SSC/Src/objdef.c **** 
1231:../SSC/Src/objdef.c ****  \brief    This function writes the requested object
1232:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
1233:../SSC/Src/objdef.c **** 
1234:../SSC/Src/objdef.c **** UINT8 OBJ_Write( UINT16 index, UINT8 subindex, UINT32 dataSize, OBJCONST TOBJECT OBJMEM * pObjEntry
1235:../SSC/Src/objdef.c **** {
 2490              	 .loc 1 1235 0
 2491              	 .cfi_startproc
 2492              	 
 2493              	 
 2494 0000 90B5     	 push {r4,r7,lr}
 2495              	.LCFI61:
 2496              	 .cfi_def_cfa_offset 12
 2497              	 .cfi_offset 4,-12
 2498              	 .cfi_offset 7,-8
 2499              	 .cfi_offset 14,-4
 2500 0002 91B0     	 sub sp,sp,#68
 2501              	.LCFI62:
 2502              	 .cfi_def_cfa_offset 80
 2503 0004 02AF     	 add r7,sp,#8
 2504              	.LCFI63:
 2505              	 .cfi_def_cfa 7,72
 2506 0006 BA60     	 str r2,[r7,#8]
 2507 0008 7B60     	 str r3,[r7,#4]
 2508 000a 0346     	 mov r3,r0
 2509 000c FB81     	 strh r3,[r7,#14]
 2510 000e 0B46     	 mov r3,r1
 2511 0010 7B73     	 strb r3,[r7,#13]
1236:../SSC/Src/objdef.c ****     UINT16 i = subindex;
 2512              	 .loc 1 1236 0
 2513 0012 7B7B     	 ldrb r3,[r7,#13]
 2514 0014 FB86     	 strh r3,[r7,#54]
1237:../SSC/Src/objdef.c ****     /* get the information of ObjCode and MaxSubindex in local variables to support different types
1238:../SSC/Src/objdef.c ****     UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 2515              	 .loc 1 1238 0
 2516 0016 7B68     	 ldr r3,[r7,#4]
 2517 0018 9B89     	 ldrh r3,[r3,#12]
 2518 001a 03F47063 	 and r3,r3,#3840
 2519 001e 1B12     	 asrs r3,r3,#8
 2520 0020 87F82330 	 strb r3,[r7,#35]
1239:../SSC/Src/objdef.c ****     UINT16 maxSubindex = 0;
 2521              	 .loc 1 1239 0
 2522 0024 0023     	 movs r3,#0
 2523 0026 BB86     	 strh r3,[r7,#52]
1240:../SSC/Src/objdef.c ****     UINT16 maxConfiguredSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJF
 2524              	 .loc 1 1240 0
 2525 0028 7B68     	 ldr r3,[r7,#4]
 2526 002a 9B89     	 ldrh r3,[r3,#12]
 2527 002c DBB2     	 uxtb r3,r3
 2528 002e 3B84     	 strh r3,[r7,#32]
1241:../SSC/Src/objdef.c ****     OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
1242:../SSC/Src/objdef.c ****     BOOL bClearSubindex0Required = FALSE;
 2529              	 .loc 1 1242 0
 2530 0030 0023     	 movs r3,#0
 2531 0032 87F83330 	 strb r3,[r7,#51]
1243:../SSC/Src/objdef.c ****     /* lastSubindex is used for complete access to make loop over the requested entries
1244:../SSC/Src/objdef.c ****        to be read, we initialize this variable with the requested subindex that only
1245:../SSC/Src/objdef.c ****        one loop will be done for a single access */
1246:../SSC/Src/objdef.c ****     UINT16 lastSubindex = subindex;
 2532              	 .loc 1 1246 0
 2533 0036 7B7B     	 ldrb r3,[r7,#13]
 2534 0038 3B86     	 strh r3,[r7,#48]
1247:../SSC/Src/objdef.c **** 
1248:../SSC/Src/objdef.c ****     /* if subindex 0 is writable, the maximum subindex should be checked in an object specific func
1249:../SSC/Src/objdef.c ****         because for the PDO mapping and PDO assign the object shall only be written if subindex 0 i
1250:../SSC/Src/objdef.c ****     if ( objCode != OBJCODE_VAR )
 2535              	 .loc 1 1250 0
 2536 003a 97F82330 	 ldrb r3,[r7,#35]
 2537 003e 072B     	 cmp r3,#7
 2538 0040 23D0     	 beq .L173
1251:../SSC/Src/objdef.c ****     {
1252:../SSC/Src/objdef.c ****         /* if the object is an array or record we have to get the maxSubindex from the
1253:../SSC/Src/objdef.c ****            actual value of subindex 0, which is stored as UINT16 at the beginning of the
1254:../SSC/Src/objdef.c ****             object's variable */
1255:../SSC/Src/objdef.c ****         maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
 2539              	 .loc 1 1255 0
 2540 0042 7B68     	 ldr r3,[r7,#4]
 2541 0044 9B69     	 ldr r3,[r3,#24]
 2542 0046 1B88     	 ldrh r3,[r3]
 2543 0048 DBB2     	 uxtb r3,r3
 2544 004a BB86     	 strh r3,[r7,#52]
1256:../SSC/Src/objdef.c **** 
1257:../SSC/Src/objdef.c ****         /*If the subindex0 of a PDO assign or PDO mapping object is 0 the maximum subindex is speci
1258:../SSC/Src/objdef.c ****         if(maxSubindex == 0 && (IS_PDO_ASSIGN(index) || IS_RX_PDO(index) || IS_TX_PDO(index)))
 2545              	 .loc 1 1258 0
 2546 004c BB8E     	 ldrh r3,[r7,#52]
 2547 004e 002B     	 cmp r3,#0
 2548 0050 1BD1     	 bne .L173
 2549              	 .loc 1 1258 0 is_stmt 0 discriminator 1
 2550 0052 FB89     	 ldrh r3,[r7,#14]
 2551 0054 41F60F42 	 movw r2,#7183
 2552 0058 9342     	 cmp r3,r2
 2553 005a 04D9     	 bls .L174
 2554              	 .loc 1 1258 0 discriminator 2
 2555 005c FB89     	 ldrh r3,[r7,#14]
 2556 005e 41F62F42 	 movw r2,#7215
 2557 0062 9342     	 cmp r3,r2
 2558 0064 0FD9     	 bls .L175
 2559              	.L174:
 2560              	 .loc 1 1258 0 discriminator 4
 2561 0066 FB89     	 ldrh r3,[r7,#14]
 2562 0068 B3F5B05F 	 cmp r3,#5632
 2563 006c 03D3     	 bcc .L176
 2564              	 .loc 1 1258 0 discriminator 5
 2565 006e FB89     	 ldrh r3,[r7,#14]
 2566 0070 B3F5C05F 	 cmp r3,#6144
 2567 0074 07D3     	 bcc .L175
 2568              	.L176:
 2569              	 .loc 1 1258 0 discriminator 7
 2570 0076 FB89     	 ldrh r3,[r7,#14]
 2571 0078 B3F5D05F 	 cmp r3,#6656
 2572 007c 05D3     	 bcc .L173
 2573              	 .loc 1 1258 0 discriminator 8
 2574 007e FB89     	 ldrh r3,[r7,#14]
 2575 0080 B3F5E05F 	 cmp r3,#7168
 2576 0084 01D2     	 bcs .L173
 2577              	.L175:
1259:../SSC/Src/objdef.c ****         {
1260:../SSC/Src/objdef.c ****             maxSubindex = maxConfiguredSubindex;
 2578              	 .loc 1 1260 0 is_stmt 1
 2579 0086 3B8C     	 ldrh r3,[r7,#32]
 2580 0088 BB86     	 strh r3,[r7,#52]
 2581              	.L173:
1261:../SSC/Src/objdef.c ****         }
1262:../SSC/Src/objdef.c ****     }
1263:../SSC/Src/objdef.c **** 
1264:../SSC/Src/objdef.c **** 
1265:../SSC/Src/objdef.c ****     if ( bCompleteAccess )
 2582              	 .loc 1 1265 0
 2583 008a 97F84C30 	 ldrb r3,[r7,#76]
 2584 008e 002B     	 cmp r3,#0
 2585 0090 12D0     	 beq .L177
1266:../SSC/Src/objdef.c ****     {
1267:../SSC/Src/objdef.c ****         if ( objCode == OBJCODE_VAR )
 2586              	 .loc 1 1267 0
 2587 0092 97F82330 	 ldrb r3,[r7,#35]
 2588 0096 072B     	 cmp r3,#7
 2589 0098 01D1     	 bne .L178
1268:../SSC/Src/objdef.c ****             /* complete access is not supported with simple objects */
1269:../SSC/Src/objdef.c ****             return ABORTIDX_UNSUPPORTED_ACCESS;
 2590              	 .loc 1 1269 0
 2591 009a 0523     	 movs r3,#5
 2592 009c CEE2     	 b .L179
 2593              	.L178:
1270:../SSC/Src/objdef.c **** 
1271:../SSC/Src/objdef.c ****         if ((subindex == 0) && (dataSize > 0))
 2594              	 .loc 1 1271 0
 2595 009e 7B7B     	 ldrb r3,[r7,#13]
 2596 00a0 002B     	 cmp r3,#0
 2597 00a2 06D1     	 bne .L180
 2598              	 .loc 1 1271 0 is_stmt 0 discriminator 1
 2599 00a4 BB68     	 ldr r3,[r7,#8]
 2600 00a6 002B     	 cmp r3,#0
 2601 00a8 03D0     	 beq .L180
1272:../SSC/Src/objdef.c ****         {
1273:../SSC/Src/objdef.c ****             /* we change the subindex 0 */
1274:../SSC/Src/objdef.c ****             maxSubindex = (UINT8) SWAPWORD(pData[0]);
 2602              	 .loc 1 1274 0 is_stmt 1
 2603 00aa BB6C     	 ldr r3,[r7,#72]
 2604 00ac 1B88     	 ldrh r3,[r3]
 2605 00ae DBB2     	 uxtb r3,r3
 2606 00b0 BB86     	 strh r3,[r7,#52]
 2607              	.L180:
1275:../SSC/Src/objdef.c ****         }
1276:../SSC/Src/objdef.c **** 
1277:../SSC/Src/objdef.c ****         /* we write until the maximum subindex */
1278:../SSC/Src/objdef.c ****         lastSubindex = maxSubindex;
 2608              	 .loc 1 1278 0
 2609 00b2 BB8E     	 ldrh r3,[r7,#52]
 2610 00b4 3B86     	 strh r3,[r7,#48]
 2611 00b6 23E0     	 b .L181
 2612              	.L177:
1279:../SSC/Src/objdef.c ****     }
1280:../SSC/Src/objdef.c ****     else
1281:../SSC/Src/objdef.c ****     if (subindex > maxSubindex)
 2613              	 .loc 1 1281 0
 2614 00b8 7B7B     	 ldrb r3,[r7,#13]
 2615 00ba 9BB2     	 uxth r3,r3
 2616 00bc BA8E     	 ldrh r2,[r7,#52]
 2617 00be 9A42     	 cmp r2,r3
 2618 00c0 01D2     	 bcs .L182
1282:../SSC/Src/objdef.c ****     {
1283:../SSC/Src/objdef.c ****         /* the maximum subindex is reached */
1284:../SSC/Src/objdef.c ****         return ABORTIDX_SUBINDEX_NOT_EXISTING;
 2619              	 .loc 1 1284 0
 2620 00c2 1123     	 movs r3,#17
 2621 00c4 BAE2     	 b .L179
 2622              	.L182:
1285:../SSC/Src/objdef.c ****     }
1286:../SSC/Src/objdef.c ****     else
1287:../SSC/Src/objdef.c ****     {
1288:../SSC/Src/objdef.c ****         /* we check the write access for single accesses here, a complete write access
1289:../SSC/Src/objdef.c ****            is allowed if at least one entry is writable (in this case the values for the
1290:../SSC/Src/objdef.c ****             read only entries shall be ignored) */
1291:../SSC/Src/objdef.c ****         /* we get the corresponding entry description */
1292:../SSC/Src/objdef.c ****         pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
 2623              	 .loc 1 1292 0
 2624 00c6 7B7B     	 ldrb r3,[r7,#13]
 2625 00c8 7868     	 ldr r0,[r7,#4]
 2626 00ca 1946     	 mov r1,r3
 2627 00cc FFF7FEFF 	 bl OBJ_GetEntryDesc
 2628 00d0 F861     	 str r0,[r7,#28]
1293:../SSC/Src/objdef.c **** 
1294:../SSC/Src/objdef.c ****         /* check if we have write access (bits 3-5 (PREOP, SAFEOP, OP) of ObjAccess)
1295:../SSC/Src/objdef.c ****            by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
1296:../SSC/Src/objdef.c ****         if ( ((UINT8) ((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) < (nAlStatus & STATE_MASK) )
 2629              	 .loc 1 1296 0
 2630 00d2 FB69     	 ldr r3,[r7,#28]
 2631 00d4 9B88     	 ldrh r3,[r3,#4]
 2632 00d6 03F03803 	 and r3,r3,#56
 2633 00da 9B10     	 asrs r3,r3,#2
 2634 00dc DBB2     	 uxtb r3,r3
 2635 00de 1A46     	 mov r2,r3
 2636 00e0 9B4B     	 ldr r3,.L243
 2637 00e2 1B78     	 ldrb r3,[r3]
 2638 00e4 03F00F03 	 and r3,r3,#15
 2639 00e8 9A42     	 cmp r2,r3
 2640 00ea 09DA     	 bge .L181
1297:../SSC/Src/objdef.c ****         {
1298:../SSC/Src/objdef.c ****             /* we don't have write access */
1299:../SSC/Src/objdef.c ****             if ( (pEntry->ObjAccess & ACCESS_WRITE) == 0 )
 2641              	 .loc 1 1299 0
 2642 00ec FB69     	 ldr r3,[r7,#28]
 2643 00ee 9B88     	 ldrh r3,[r3,#4]
 2644 00f0 03F03803 	 and r3,r3,#56
 2645 00f4 002B     	 cmp r3,#0
 2646 00f6 01D1     	 bne .L183
1300:../SSC/Src/objdef.c ****             {
1301:../SSC/Src/objdef.c ****                 /* it is a read only entry */
1302:../SSC/Src/objdef.c ****                 return ABORTIDX_READ_ONLY_ENTRY;
 2647              	 .loc 1 1302 0
 2648 00f8 0723     	 movs r3,#7
 2649 00fa 9FE2     	 b .L179
 2650              	.L183:
1303:../SSC/Src/objdef.c ****             }
1304:../SSC/Src/objdef.c ****             else
1305:../SSC/Src/objdef.c ****             {
1306:../SSC/Src/objdef.c ****                 /* we don't have write access in this state */
1307:../SSC/Src/objdef.c ****                 return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
 2651              	 .loc 1 1307 0
 2652 00fc 1A23     	 movs r3,#26
 2653 00fe 9DE2     	 b .L179
 2654              	.L181:
1308:../SSC/Src/objdef.c ****             }
1309:../SSC/Src/objdef.c ****         }
1310:../SSC/Src/objdef.c ****     }
1311:../SSC/Src/objdef.c **** 
1312:../SSC/Src/objdef.c ****     /* Subindex 0 shall be set to zero if a single PDO / PDO assign entry is written
1313:../SSC/Src/objdef.c ****     or a complete access without subindex0 is requested */
1314:../SSC/Src/objdef.c ****     if((subindex > 0) &&
 2655              	 .loc 1 1314 0
 2656 0100 7B7B     	 ldrb r3,[r7,#13]
 2657 0102 002B     	 cmp r3,#0
 2658 0104 24D0     	 beq .L184
 2659              	 .loc 1 1314 0 is_stmt 0 discriminator 1
 2660 0106 FB89     	 ldrh r3,[r7,#14]
 2661 0108 41F60F42 	 movw r2,#7183
 2662 010c 9342     	 cmp r3,r2
 2663 010e 04D9     	 bls .L185
1315:../SSC/Src/objdef.c ****         (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index))
 2664              	 .loc 1 1315 0 is_stmt 1
 2665 0110 FB89     	 ldrh r3,[r7,#14]
 2666 0112 41F62F42 	 movw r2,#7215
 2667 0116 9342     	 cmp r3,r2
 2668 0118 0FD9     	 bls .L186
 2669              	.L185:
 2670              	 .loc 1 1315 0 is_stmt 0 discriminator 1
 2671 011a FB89     	 ldrh r3,[r7,#14]
 2672 011c B3F5B05F 	 cmp r3,#5632
 2673 0120 03D3     	 bcc .L187
 2674              	 .loc 1 1315 0 discriminator 2
 2675 0122 FB89     	 ldrh r3,[r7,#14]
 2676 0124 B3F5C05F 	 cmp r3,#6144
 2677 0128 07D3     	 bcc .L186
 2678              	.L187:
 2679              	 .loc 1 1315 0 discriminator 4
 2680 012a FB89     	 ldrh r3,[r7,#14]
 2681 012c B3F5D05F 	 cmp r3,#6656
 2682 0130 0ED3     	 bcc .L184
 2683              	 .loc 1 1315 0 discriminator 5
 2684 0132 FB89     	 ldrh r3,[r7,#14]
 2685 0134 B3F5E05F 	 cmp r3,#7168
 2686 0138 0AD2     	 bcs .L184
 2687              	.L186:
 2688              	.LBB17:
1316:../SSC/Src/objdef.c ****         )
1317:../SSC/Src/objdef.c ****     {
1318:../SSC/Src/objdef.c ****         /*Check if Subindex0 was cleared before*/
1319:../SSC/Src/objdef.c ****         UINT16 Subindex0 = (*(UINT16 *)pObjEntry->pVarPtr) & 0x00FF;
 2689              	 .loc 1 1319 0 is_stmt 1
 2690 013a 7B68     	 ldr r3,[r7,#4]
 2691 013c 9B69     	 ldr r3,[r3,#24]
 2692 013e 1B88     	 ldrh r3,[r3]
 2693 0140 DBB2     	 uxtb r3,r3
 2694 0142 7B83     	 strh r3,[r7,#26]
1320:../SSC/Src/objdef.c ****         if(Subindex0 != 0x00)
 2695              	 .loc 1 1320 0
 2696 0144 7B8B     	 ldrh r3,[r7,#26]
 2697 0146 002B     	 cmp r3,#0
 2698 0148 02D0     	 beq .L184
1321:../SSC/Src/objdef.c ****             bClearSubindex0Required = TRUE;
 2699              	 .loc 1 1321 0
 2700 014a 0123     	 movs r3,#1
 2701 014c 87F83330 	 strb r3,[r7,#51]
 2702              	.L184:
 2703              	.LBE17:
1322:../SSC/Src/objdef.c ****     }
1323:../SSC/Src/objdef.c **** 
1324:../SSC/Src/objdef.c ****     if ( pObjEntry->Write != NULL )
 2704              	 .loc 1 1324 0
 2705 0150 7B68     	 ldr r3,[r7,#4]
 2706 0152 1B6A     	 ldr r3,[r3,#32]
 2707 0154 002B     	 cmp r3,#0
 2708 0156 0DD0     	 beq .L188
1325:../SSC/Src/objdef.c ****     {
1326:../SSC/Src/objdef.c ****         /* Write function is defined, we call the object specific write function */
1327:../SSC/Src/objdef.c ****         return pObjEntry->Write(index, subindex, dataSize, pData, bCompleteAccess);
 2709              	 .loc 1 1327 0
 2710 0158 7B68     	 ldr r3,[r7,#4]
 2711 015a 1C6A     	 ldr r4,[r3,#32]
 2712 015c F989     	 ldrh r1,[r7,#14]
 2713 015e 7A7B     	 ldrb r2,[r7,#13]
 2714 0160 97F84C30 	 ldrb r3,[r7,#76]
 2715 0164 0093     	 str r3,[sp]
 2716 0166 0846     	 mov r0,r1
 2717 0168 1146     	 mov r1,r2
 2718 016a BA68     	 ldr r2,[r7,#8]
 2719 016c BB6C     	 ldr r3,[r7,#72]
 2720 016e A047     	 blx r4
 2721 0170 0346     	 mov r3,r0
 2722 0172 63E2     	 b .L179
 2723              	.L188:
 2724              	.LBB18:
1328:../SSC/Src/objdef.c ****     }
1329:../SSC/Src/objdef.c ****     else
1330:../SSC/Src/objdef.c ****     {
1331:../SSC/Src/objdef.c ****         UINT8 bWritten = 0;
 2725              	 .loc 1 1331 0
 2726 0174 0023     	 movs r3,#0
 2727 0176 87F82F30 	 strb r3,[r7,#47]
1332:../SSC/Src/objdef.c ****         UINT8 result = ABORTIDX_READ_ONLY_ENTRY;
 2728              	 .loc 1 1332 0
 2729 017a 0723     	 movs r3,#7
 2730 017c 87F82E30 	 strb r3,[r7,#46]
1333:../SSC/Src/objdef.c **** 
1334:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) ECAT*/
1335:../SSC/Src/objdef.c ****         if (dataSize == 0)
 2731              	 .loc 1 1335 0
 2732 0180 BB68     	 ldr r3,[r7,#8]
 2733 0182 002B     	 cmp r3,#0
 2734 0184 01D1     	 bne .L189
1336:../SSC/Src/objdef.c ****         {
1337:../SSC/Src/objdef.c ****            return 0; //no error
 2735              	 .loc 1 1337 0
 2736 0186 0023     	 movs r3,#0
 2737 0188 58E2     	 b .L179
 2738              	.L189:
1338:../SSC/Src/objdef.c ****         }
1339:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) ECAT*/
1340:../SSC/Src/objdef.c **** 
1341:../SSC/Src/objdef.c ****         /* we use the standard write function */
1342:../SSC/Src/objdef.c ****         for (i = subindex; i <= lastSubindex; i++)
 2739              	 .loc 1 1342 0
 2740 018a 7B7B     	 ldrb r3,[r7,#13]
 2741 018c FB86     	 strh r3,[r7,#54]
 2742 018e 48E2     	 b .L190
 2743              	.L241:
 2744              	.LBB19:
1343:../SSC/Src/objdef.c ****         {
1344:../SSC/Src/objdef.c ****             /* if only a single entry is requested, this loop will only be done once */
1345:../SSC/Src/objdef.c ****             UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
 2745              	 .loc 1 1345 0
 2746 0190 7B68     	 ldr r3,[r7,#4]
 2747 0192 9B69     	 ldr r3,[r3,#24]
 2748 0194 BB62     	 str r3,[r7,#40]
1346:../SSC/Src/objdef.c ****             UINT16 bitOffset = 0;
 2749              	 .loc 1 1346 0
 2750 0196 0023     	 movs r3,#0
 2751 0198 3B83     	 strh r3,[r7,#24]
1347:../SSC/Src/objdef.c **** 
1348:../SSC/Src/objdef.c ****             /* we get the corresponding entry description */
1349:../SSC/Src/objdef.c ****             pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
 2752              	 .loc 1 1349 0
 2753 019a FB8E     	 ldrh r3,[r7,#54]
 2754 019c DBB2     	 uxtb r3,r3
 2755 019e 7868     	 ldr r0,[r7,#4]
 2756 01a0 1946     	 mov r1,r3
 2757 01a2 FFF7FEFF 	 bl OBJ_GetEntryDesc
 2758 01a6 F861     	 str r0,[r7,#28]
1350:../SSC/Src/objdef.c **** 
1351:../SSC/Src/objdef.c ****             /*Get the bitOffset before check the access rights to calculate pData offset*/
1352:../SSC/Src/objdef.c ****             bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
 2759              	 .loc 1 1352 0
 2760 01a8 FB8E     	 ldrh r3,[r7,#54]
 2761 01aa DBB2     	 uxtb r3,r3
 2762 01ac 1846     	 mov r0,r3
 2763 01ae 7968     	 ldr r1,[r7,#4]
 2764 01b0 FFF7FEFF 	 bl OBJ_GetEntryOffset
 2765 01b4 0346     	 mov r3,r0
 2766 01b6 3B83     	 strh r3,[r7,#24]
1353:../SSC/Src/objdef.c **** 
1354:../SSC/Src/objdef.c ****             /* we check if we have write access (bits 3-5 (PREOP, SAFEOP, OP) of ObjAccess)
1355:../SSC/Src/objdef.c ****                by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
1356:../SSC/Src/objdef.c ****             if ( ((UINT8)((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) >= (nAlStatus & STATE_MASK) )
 2767              	 .loc 1 1356 0
 2768 01b8 FB69     	 ldr r3,[r7,#28]
 2769 01ba 9B88     	 ldrh r3,[r3,#4]
 2770 01bc 03F03803 	 and r3,r3,#56
 2771 01c0 9B10     	 asrs r3,r3,#2
 2772 01c2 DBB2     	 uxtb r3,r3
 2773 01c4 1A46     	 mov r2,r3
 2774 01c6 624B     	 ldr r3,.L243
 2775 01c8 1B78     	 ldrb r3,[r3]
 2776 01ca 03F00F03 	 and r3,r3,#15
 2777 01ce 9A42     	 cmp r2,r3
 2778 01d0 C0F2FC81 	 blt .L191
1357:../SSC/Src/objdef.c ****             {
1358:../SSC/Src/objdef.c ****                 /* we have write access for this entry */
1359:../SSC/Src/objdef.c ****                 if (i != 0)
 2779              	 .loc 1 1359 0
 2780 01d4 FB8E     	 ldrh r3,[r7,#54]
 2781 01d6 002B     	 cmp r3,#0
 2782 01d8 06D0     	 beq .L192
1360:../SSC/Src/objdef.c ****                 {
1361:../SSC/Src/objdef.c ****                     /* we increment the variable pointer to the corresponding word address */
1362:../SSC/Src/objdef.c ****                     pVarPtr += (bitOffset >> 4);
 2783              	 .loc 1 1362 0
 2784 01da 3B8B     	 ldrh r3,[r7,#24]
 2785 01dc 1B09     	 lsrs r3,r3,#4
 2786 01de 9BB2     	 uxth r3,r3
 2787 01e0 5B00     	 lsls r3,r3,#1
 2788 01e2 BA6A     	 ldr r2,[r7,#40]
 2789 01e4 1344     	 add r3,r3,r2
 2790 01e6 BB62     	 str r3,[r7,#40]
 2791              	.L192:
1363:../SSC/Src/objdef.c ****                 }
1364:../SSC/Src/objdef.c **** 
1365:../SSC/Src/objdef.c **** 
1366:../SSC/Src/objdef.c ****                 if ( i == subindex                                     /* requested entry */
 2792              	 .loc 1 1366 0
 2793 01e8 7B7B     	 ldrb r3,[r7,#13]
 2794 01ea 9BB2     	 uxth r3,r3
 2795 01ec FA8E     	 ldrh r2,[r7,#54]
 2796 01ee 9A42     	 cmp r2,r3
 2797 01f0 0AD0     	 beq .L193
1367:../SSC/Src/objdef.c ****                   || (bCompleteAccess && i >= subindex) )       /* complete access and entry should
 2798              	 .loc 1 1367 0
 2799 01f2 97F84C30 	 ldrb r3,[r7,#76]
 2800 01f6 002B     	 cmp r3,#0
 2801 01f8 00F01082 	 beq .L237
 2802              	 .loc 1 1367 0 is_stmt 0 discriminator 1
 2803 01fc 7B7B     	 ldrb r3,[r7,#13]
 2804 01fe 9BB2     	 uxth r3,r3
 2805 0200 FA8E     	 ldrh r2,[r7,#54]
 2806 0202 9A42     	 cmp r2,r3
 2807 0204 C0F00A82 	 bcc .L237
 2808              	.L193:
 2809              	.LBB20:
1368:../SSC/Src/objdef.c ****                 {
1369:../SSC/Src/objdef.c ****                     UINT16 bitMask;
1370:../SSC/Src/objdef.c **** 
1371:../SSC/Src/objdef.c ****                     /* we have to copy the entry */
1372:../SSC/Src/objdef.c ****                     if (i == 0 && objCode != OBJCODE_VAR)
 2810              	 .loc 1 1372 0 is_stmt 1
 2811 0208 FB8E     	 ldrh r3,[r7,#54]
 2812 020a 002B     	 cmp r3,#0
 2813 020c 15D1     	 bne .L195
 2814              	 .loc 1 1372 0 is_stmt 0 discriminator 1
 2815 020e 97F82330 	 ldrb r3,[r7,#35]
 2816 0212 072B     	 cmp r3,#7
 2817 0214 11D0     	 beq .L195
 2818              	.LBB21:
1373:../SSC/Src/objdef.c ****                     {
1374:../SSC/Src/objdef.c ****                         /*check if the value for subindex0 is valid */
1375:../SSC/Src/objdef.c ****                         UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
 2819              	 .loc 1 1375 0 is_stmt 1
 2820 0216 BB6C     	 ldr r3,[r7,#72]
 2821 0218 1B88     	 ldrh r3,[r3]
 2822 021a FB74     	 strb r3,[r7,#19]
1376:../SSC/Src/objdef.c ****                         if(maxConfiguredSubindex < NewSubindex0)
 2823              	 .loc 1 1376 0
 2824 021c FB7C     	 ldrb r3,[r7,#19]
 2825 021e 9BB2     	 uxth r3,r3
 2826 0220 3A8C     	 ldrh r2,[r7,#32]
 2827 0222 9A42     	 cmp r2,r3
 2828 0224 01D2     	 bcs .L196
1377:../SSC/Src/objdef.c ****                         {
1378:../SSC/Src/objdef.c ****                             return ABORTIDX_VALUE_TOO_GREAT;
 2829              	 .loc 1 1378 0
 2830 0226 1323     	 movs r3,#19
 2831 0228 08E2     	 b .L179
 2832              	.L196:
1379:../SSC/Src/objdef.c ****                         }
1380:../SSC/Src/objdef.c **** 
1381:../SSC/Src/objdef.c ****                         /* subindex 0 of an array or record shall be written */
1382:../SSC/Src/objdef.c **** /* ECATCHANGE_START(V5.11) SDO5*/
1383:../SSC/Src/objdef.c ****                         pVarPtr[0] = SWAPWORD(pData[0]);
 2833              	 .loc 1 1383 0
 2834 022a BB6C     	 ldr r3,[r7,#72]
 2835 022c 1A88     	 ldrh r2,[r3]
 2836 022e BB6A     	 ldr r3,[r7,#40]
 2837 0230 1A80     	 strh r2,[r3]
1384:../SSC/Src/objdef.c **** /* ECATCHANGE_END(V5.11) SDO5*/
1385:../SSC/Src/objdef.c ****                         /* we increment the destination pointer by 2 because the subindex 0 will be
1386:../SSC/Src/objdef.c ****                            transmitted as UINT16 for a complete access */
1387:../SSC/Src/objdef.c ****                         pData++;
 2838              	 .loc 1 1387 0
 2839 0232 BB6C     	 ldr r3,[r7,#72]
 2840 0234 0233     	 adds r3,r3,#2
 2841 0236 BB64     	 str r3,[r7,#72]
 2842              	.LBE21:
1373:../SSC/Src/objdef.c ****                         /*check if the value for subindex0 is valid */
 2843              	 .loc 1 1373 0
 2844 0238 C4E1     	 b .L197
 2845              	.L195:
 2846              	.LBB22:
1388:../SSC/Src/objdef.c ****                     }
1389:../SSC/Src/objdef.c ****                     else
1390:../SSC/Src/objdef.c ****                     {
1391:../SSC/Src/objdef.c ****                         UINT16 dataType = pEntry->DataType;
 2847              	 .loc 1 1391 0
 2848 023a FB69     	 ldr r3,[r7,#28]
 2849 023c 1B88     	 ldrh r3,[r3]
 2850 023e FB84     	 strh r3,[r7,#38]
1392:../SSC/Src/objdef.c ****                         if (pEntry->DataType >= 0x700)
 2851              	 .loc 1 1392 0
 2852 0240 FB69     	 ldr r3,[r7,#28]
 2853 0242 1B88     	 ldrh r3,[r3]
 2854 0244 B3F5E06F 	 cmp r3,#1792
 2855 0248 15D3     	 bcc .L198
1393:../SSC/Src/objdef.c ****                         {
1394:../SSC/Src/objdef.c ****                             /* the ENUM data types are defined from index 0x700 in this example
1395:../SSC/Src/objdef.c ****                                convert in standard data type for the write access */
1396:../SSC/Src/objdef.c ****                             if ( pEntry->BitLength <= 8 )
 2856              	 .loc 1 1396 0
 2857 024a FB69     	 ldr r3,[r7,#28]
 2858 024c 5B88     	 ldrh r3,[r3,#2]
 2859 024e 082B     	 cmp r3,#8
 2860 0250 04D8     	 bhi .L199
1397:../SSC/Src/objdef.c ****                                 dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
 2861              	 .loc 1 1397 0
 2862 0252 FB69     	 ldr r3,[r7,#28]
 2863 0254 5B88     	 ldrh r3,[r3,#2]
 2864 0256 2F33     	 adds r3,r3,#47
 2865 0258 FB84     	 strh r3,[r7,#38]
 2866 025a 0CE0     	 b .L198
 2867              	.L199:
1398:../SSC/Src/objdef.c ****                             else if ( pEntry->BitLength == 16 )
 2868              	 .loc 1 1398 0
 2869 025c FB69     	 ldr r3,[r7,#28]
 2870 025e 5B88     	 ldrh r3,[r3,#2]
 2871 0260 102B     	 cmp r3,#16
 2872 0262 02D1     	 bne .L200
1399:../SSC/Src/objdef.c ****                                 dataType = DEFTYPE_UNSIGNED16;
 2873              	 .loc 1 1399 0
 2874 0264 0623     	 movs r3,#6
 2875 0266 FB84     	 strh r3,[r7,#38]
 2876 0268 05E0     	 b .L198
 2877              	.L200:
1400:../SSC/Src/objdef.c ****                             else if ( pEntry->BitLength == 32 )
 2878              	 .loc 1 1400 0
 2879 026a FB69     	 ldr r3,[r7,#28]
 2880 026c 5B88     	 ldrh r3,[r3,#2]
 2881 026e 202B     	 cmp r3,#32
 2882 0270 01D1     	 bne .L198
1401:../SSC/Src/objdef.c ****                                 dataType = DEFTYPE_UNSIGNED32;
 2883              	 .loc 1 1401 0
 2884 0272 0723     	 movs r3,#7
 2885 0274 FB84     	 strh r3,[r7,#38]
 2886              	.L198:
1402:../SSC/Src/objdef.c ****                         }
1403:../SSC/Src/objdef.c **** 
1404:../SSC/Src/objdef.c ****                         switch (dataType)
 2887              	 .loc 1 1404 0
 2888 0276 FB8C     	 ldrh r3,[r7,#38]
 2889 0278 112B     	 cmp r3,#17
 2890 027a 00F04D81 	 beq .L202
 2891 027e 112B     	 cmp r3,#17
 2892 0280 1EDC     	 bgt .L203
 2893 0282 052B     	 cmp r3,#5
 2894 0284 66D0     	 beq .L204
 2895 0286 052B     	 cmp r3,#5
 2896 0288 0DDC     	 bgt .L205
 2897 028a 022B     	 cmp r3,#2
 2898 028c 04DC     	 bgt .L206
 2899 028e 012B     	 cmp r3,#1
 2900 0290 60DA     	 bge .L204
 2901 0292 002B     	 cmp r3,#0
 2902 0294 3BD0     	 beq .L207
 2903 0296 93E1     	 b .L201
 2904              	.L206:
 2905 0298 032B     	 cmp r3,#3
 2906 029a 00F0B580 	 beq .L208
 2907 029e 042B     	 cmp r3,#4
 2908 02a0 00F01281 	 beq .L209
 2909 02a4 8CE1     	 b .L201
 2910              	.L205:
 2911 02a6 082B     	 cmp r3,#8
 2912 02a8 03DC     	 bgt .L210
 2913 02aa 072B     	 cmp r3,#7
 2914 02ac 80F20C81 	 bge .L209
 2915 02b0 AAE0     	 b .L208
 2916              	.L210:
 2917 02b2 092B     	 cmp r3,#9
 2918 02b4 00F04E81 	 beq .L211
 2919 02b8 0B2B     	 cmp r3,#11
 2920 02ba 00F38181 	 bgt .L201
 2921 02be 64E1     	 b .L212
 2922              	.L203:
 2923 02c0 2D2B     	 cmp r3,#45
 2924 02c2 47D0     	 beq .L204
 2925 02c4 2D2B     	 cmp r3,#45
 2926 02c6 11DC     	 bgt .L213
 2927 02c8 1E2B     	 cmp r3,#30
 2928 02ca 43D0     	 beq .L204
 2929 02cc 1E2B     	 cmp r3,#30
 2930 02ce 06DC     	 bgt .L214
 2931 02d0 152B     	 cmp r3,#21
 2932 02d2 00F02181 	 beq .L202
 2933 02d6 1B2B     	 cmp r3,#27
 2934 02d8 00F01E81 	 beq .L202
 2935 02dc 70E1     	 b .L201
 2936              	.L214:
 2937 02de 1F2B     	 cmp r3,#31
 2938 02e0 00F09280 	 beq .L208
 2939 02e4 202B     	 cmp r3,#32
 2940 02e6 00F0EF80 	 beq .L209
 2941 02ea 69E1     	 b .L201
 2942              	.L213:
 2943 02ec 372B     	 cmp r3,#55
 2944 02ee 08DC     	 bgt .L215
 2945 02f0 302B     	 cmp r3,#48
 2946 02f2 2FDA     	 bge .L204
 2947 02f4 2E2B     	 cmp r3,#46
 2948 02f6 00F08780 	 beq .L208
 2949 02fa 2F2B     	 cmp r3,#47
 2950 02fc 00F0E480 	 beq .L209
 2951 0300 5EE1     	 b .L201
 2952              	.L215:
 2953 0302 A3F51873 	 sub r3,r3,#608
 2954 0306 032B     	 cmp r3,#3
 2955 0308 00F25A81 	 bhi .L201
 2956 030c 3DE1     	 b .L212
 2957              	.L207:
1405:../SSC/Src/objdef.c ****                         {
1406:../SSC/Src/objdef.c ****                         case DEFTYPE_NULL:
1407:../SSC/Src/objdef.c ****                             if(bCompleteAccess)
 2958              	 .loc 1 1407 0
 2959 030e 97F84C30 	 ldrb r3,[r7,#76]
 2960 0312 002B     	 cmp r3,#0
 2961 0314 1AD0     	 beq .L216
1408:../SSC/Src/objdef.c ****                             {
1409:../SSC/Src/objdef.c ****                                 /*Handle alignment entry*/
1410:../SSC/Src/objdef.c ****                                 if (((pEntry->BitLength & 0xF) > 0)
 2962              	 .loc 1 1410 0
 2963 0316 FB69     	 ldr r3,[r7,#28]
 2964 0318 5B88     	 ldrh r3,[r3,#2]
 2965 031a 03F00F03 	 and r3,r3,#15
 2966 031e 002B     	 cmp r3,#0
 2967 0320 0ADD     	 ble .L217
1411:../SSC/Src/objdef.c ****                                     && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
 2968              	 .loc 1 1411 0
 2969 0322 3B8B     	 ldrh r3,[r7,#24]
 2970 0324 FA69     	 ldr r2,[r7,#28]
 2971 0326 5288     	 ldrh r2,[r2,#2]
 2972 0328 1344     	 add r3,r3,r2
 2973 032a 03F00F03 	 and r3,r3,#15
 2974 032e 002B     	 cmp r3,#0
 2975 0330 02D1     	 bne .L217
1412:../SSC/Src/objdef.c ****                                 {
1413:../SSC/Src/objdef.c ****                                     /* we have reached the UINT16 border */
1414:../SSC/Src/objdef.c ****                                     pData++;
 2976              	 .loc 1 1414 0
 2977 0332 BB6C     	 ldr r3,[r7,#72]
 2978 0334 0233     	 adds r3,r3,#2
 2979 0336 BB64     	 str r3,[r7,#72]
 2980              	.L217:
1415:../SSC/Src/objdef.c ****                                 }
1416:../SSC/Src/objdef.c **** 
1417:../SSC/Src/objdef.c ****                                 /*increment WORD offset*/
1418:../SSC/Src/objdef.c ****                                 pData += ((pEntry->BitLength & 0xF0) >> 4);
 2981              	 .loc 1 1418 0
 2982 0338 FB69     	 ldr r3,[r7,#28]
 2983 033a 5B88     	 ldrh r3,[r3,#2]
 2984 033c 03F0F003 	 and r3,r3,#240
 2985 0340 1B11     	 asrs r3,r3,#4
 2986 0342 5B00     	 lsls r3,r3,#1
 2987 0344 BA6C     	 ldr r2,[r7,#72]
 2988 0346 1344     	 add r3,r3,r2
 2989 0348 BB64     	 str r3,[r7,#72]
1419:../SSC/Src/objdef.c ****                             }
1420:../SSC/Src/objdef.c ****                             else
1421:../SSC/Src/objdef.c ****                             {
1422:../SSC/Src/objdef.c ****                                 return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
1423:../SSC/Src/objdef.c ****                             }
1424:../SSC/Src/objdef.c ****                             break;
 2990              	 .loc 1 1424 0
 2991 034a 3BE1     	 b .L197
 2992              	.L216:
1422:../SSC/Src/objdef.c ****                             }
 2993              	 .loc 1 1422 0
 2994 034c 1823     	 movs r3,#24
 2995 034e 75E1     	 b .L179
 2996              	.L244:
 2997              	 .align 2
 2998              	.L243:
 2999 0350 00000000 	 .word nAlStatus
 3000              	.L204:
 3001              	.LBB23:
1425:../SSC/Src/objdef.c ****                         case     DEFTYPE_BOOLEAN:
1426:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT1:
1427:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT2:
1428:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT3:
1429:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT4:
1430:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT5:
1431:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT6:
1432:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT7:
1433:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT8:
1434:../SSC/Src/objdef.c ****                         case     DEFTYPE_BITARR8:
1435:../SSC/Src/objdef.c ****                             /* in this example the objects are defined in that way,
1436:../SSC/Src/objdef.c ****                                that the bit types are always inside a 16-bit field,
1437:../SSC/Src/objdef.c ****                                and shall not overlap a byte border*/
1438:../SSC/Src/objdef.c ****                         case    DEFTYPE_INTEGER8:
1439:../SSC/Src/objdef.c ****                         case    DEFTYPE_UNSIGNED8:
1440:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO9*/
1441:../SSC/Src/objdef.c ****                         case    DEFTYPE_BYTE :
1442:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO9*/
1443:../SSC/Src/objdef.c ****                         {
1444:../SSC/Src/objdef.c ****                             /* depending on the bitOffset we have to copy the Hi or the Lo-Byte */
1445:../SSC/Src/objdef.c ****                             UINT16 TmpValue = 0x0000;
 3002              	 .loc 1 1445 0
 3003 0354 0023     	 movs r3,#0
 3004 0356 BB84     	 strh r3,[r7,#36]
1446:../SSC/Src/objdef.c **** 
1447:../SSC/Src/objdef.c ****                             bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
 3005              	 .loc 1 1447 0
 3006 0358 FB69     	 ldr r3,[r7,#28]
 3007 035a 5B88     	 ldrh r3,[r3,#2]
 3008 035c 1A46     	 mov r2,r3
 3009 035e 9F4B     	 ldr r3,.L245
 3010 0360 33F81230 	 ldrh r3,[r3,r2,lsl#1]
 3011 0364 1A46     	 mov r2,r3
 3012 0366 3B8B     	 ldrh r3,[r7,#24]
 3013 0368 03F00F03 	 and r3,r3,#15
 3014 036c 02FA03F3 	 lsl r3,r2,r3
 3015 0370 FB82     	 strh r3,[r7,#22]
1448:../SSC/Src/objdef.c **** 
1449:../SSC/Src/objdef.c ****                             /*Swap object data (if required); all masks and offsets are defined for
1450:../SSC/Src/objdef.c ****                             TmpValue = SWAPWORD(pVarPtr[0]);
 3016              	 .loc 1 1450 0
 3017 0372 BB6A     	 ldr r3,[r7,#40]
 3018 0374 1B88     	 ldrh r3,[r3]
 3019 0376 BB84     	 strh r3,[r7,#36]
1451:../SSC/Src/objdef.c **** 
1452:../SSC/Src/objdef.c ****                             /*Clear corresponding bits*/
1453:../SSC/Src/objdef.c ****                             TmpValue &= ~bitMask;
 3020              	 .loc 1 1453 0
 3021 0378 FB8A     	 ldrh r3,[r7,#22]
 3022 037a DB43     	 mvns r3,r3
 3023 037c 9AB2     	 uxth r2,r3
 3024 037e BB8C     	 ldrh r3,[r7,#36]
 3025 0380 1340     	 ands r3,r3,r2
 3026 0382 9BB2     	 uxth r3,r3
 3027 0384 BB84     	 strh r3,[r7,#36]
1454:../SSC/Src/objdef.c **** 
1455:../SSC/Src/objdef.c **** /* ECATCHANGE_START(V5.11) SDO7*/
1456:../SSC/Src/objdef.c ****                             if (bCompleteAccess) 
 3028              	 .loc 1 1456 0
 3029 0386 97F84C30 	 ldrb r3,[r7,#76]
 3030 038a 002B     	 cmp r3,#0
 3031 038c 08D0     	 beq .L219
1457:../SSC/Src/objdef.c ****                             {
1458:../SSC/Src/objdef.c ****                                 /*shifting is not required for Complete access because the bits are
1459:../SSC/Src/objdef.c ****                                 TmpValue |= (SWAPWORD(pData[0]) & bitMask);
 3032              	 .loc 1 1459 0
 3033 038e BB6C     	 ldr r3,[r7,#72]
 3034 0390 1A88     	 ldrh r2,[r3]
 3035 0392 FB8A     	 ldrh r3,[r7,#22]
 3036 0394 1340     	 ands r3,r3,r2
 3037 0396 9AB2     	 uxth r2,r3
 3038 0398 BB8C     	 ldrh r3,[r7,#36]
 3039 039a 1343     	 orrs r3,r3,r2
 3040 039c BB84     	 strh r3,[r7,#36]
 3041 039e 23E0     	 b .L220
 3042              	.L219:
1460:../SSC/Src/objdef.c ****                             }
1461:../SSC/Src/objdef.c ****                             else
1462:../SSC/Src/objdef.c ****                             {
1463:../SSC/Src/objdef.c ****                                 if((SWAPWORD(pData[0]) & ~cBitMask[pEntry->BitLength]))
 3043              	 .loc 1 1463 0
 3044 03a0 BB6C     	 ldr r3,[r7,#72]
 3045 03a2 1B88     	 ldrh r3,[r3]
 3046 03a4 1A46     	 mov r2,r3
 3047 03a6 FB69     	 ldr r3,[r7,#28]
 3048 03a8 5B88     	 ldrh r3,[r3,#2]
 3049 03aa 1946     	 mov r1,r3
 3050 03ac 8B4B     	 ldr r3,.L245
 3051 03ae 33F81130 	 ldrh r3,[r3,r1,lsl#1]
 3052 03b2 DB43     	 mvns r3,r3
 3053 03b4 1340     	 ands r3,r3,r2
 3054 03b6 002B     	 cmp r3,#0
 3055 03b8 01D0     	 beq .L221
1464:../SSC/Src/objdef.c ****                                 {
1465:../SSC/Src/objdef.c ****                                     /*written value exceed entry range*/
1466:../SSC/Src/objdef.c ****                                     return ABORTIDX_VALUE_EXCEEDED;
 3056              	 .loc 1 1466 0
 3057 03ba 1223     	 movs r3,#18
 3058 03bc 3EE1     	 b .L179
 3059              	.L221:
1467:../SSC/Src/objdef.c ****                                 }
1468:../SSC/Src/objdef.c ****                                 else
1469:../SSC/Src/objdef.c ****                                 {
1470:../SSC/Src/objdef.c ****                                     /*Shift Bits to corresponding offset within the object memory*/
1471:../SSC/Src/objdef.c ****                                     TmpValue |= ((SWAPWORD(pData[0]) & cBitMask[pEntry->BitLength])
 3060              	 .loc 1 1471 0
 3061 03be BB6C     	 ldr r3,[r7,#72]
 3062 03c0 1A88     	 ldrh r2,[r3]
 3063 03c2 FB69     	 ldr r3,[r7,#28]
 3064 03c4 5B88     	 ldrh r3,[r3,#2]
 3065 03c6 1946     	 mov r1,r3
 3066 03c8 844B     	 ldr r3,.L245
 3067 03ca 33F81130 	 ldrh r3,[r3,r1,lsl#1]
 3068 03ce 1340     	 ands r3,r3,r2
 3069 03d0 9BB2     	 uxth r3,r3
 3070 03d2 1A46     	 mov r2,r3
 3071 03d4 3B8B     	 ldrh r3,[r7,#24]
 3072 03d6 03F00F03 	 and r3,r3,#15
 3073 03da 02FA03F3 	 lsl r3,r2,r3
 3074 03de 9AB2     	 uxth r2,r3
 3075 03e0 BB8C     	 ldrh r3,[r7,#36]
 3076 03e2 1343     	 orrs r3,r3,r2
 3077 03e4 9BB2     	 uxth r3,r3
 3078 03e6 BB84     	 strh r3,[r7,#36]
 3079              	.L220:
1472:../SSC/Src/objdef.c ****                                 }
1473:../SSC/Src/objdef.c ****                             }
1474:../SSC/Src/objdef.c **** /* ECATCHANGE_END(V5.11) SDO7*/
1475:../SSC/Src/objdef.c **** 
1476:../SSC/Src/objdef.c ****                             /*Swap written data to big endian format (if required)*/
1477:../SSC/Src/objdef.c ****                             pVarPtr[0] = SWAPWORD(TmpValue);
 3080              	 .loc 1 1477 0
 3081 03e8 BB6A     	 ldr r3,[r7,#40]
 3082 03ea BA8C     	 ldrh r2,[r7,#36]
 3083 03ec 1A80     	 strh r2,[r3]
1478:../SSC/Src/objdef.c **** 
1479:../SSC/Src/objdef.c ****                             if ( ((bitOffset+pEntry->BitLength) & 0x0F) == 0 )
 3084              	 .loc 1 1479 0
 3085 03ee 3B8B     	 ldrh r3,[r7,#24]
 3086 03f0 FA69     	 ldr r2,[r7,#28]
 3087 03f2 5288     	 ldrh r2,[r2,#2]
 3088 03f4 1344     	 add r3,r3,r2
 3089 03f6 03F00F03 	 and r3,r3,#15
 3090 03fa 002B     	 cmp r3,#0
 3091 03fc 03D1     	 bne .L222
1480:../SSC/Src/objdef.c ****                                 /* we have reached the UINT16 border */
1481:../SSC/Src/objdef.c ****                                 pData++;
 3092              	 .loc 1 1481 0
 3093 03fe BB6C     	 ldr r3,[r7,#72]
 3094 0400 0233     	 adds r3,r3,#2
 3095 0402 BB64     	 str r3,[r7,#72]
 3096              	.LBE23:
1482:../SSC/Src/objdef.c ****                         }
1483:../SSC/Src/objdef.c ****                             break;
 3097              	 .loc 1 1483 0
 3098 0404 DEE0     	 b .L197
 3099              	.L222:
 3100 0406 DDE0     	 b .L197
 3101              	.L208:
1484:../SSC/Src/objdef.c ****                         case    DEFTYPE_INTEGER16:
1485:../SSC/Src/objdef.c ****                         case    DEFTYPE_UNSIGNED16:
1486:../SSC/Src/objdef.c ****                         case    DEFTYPE_BITARR16:
1487:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO9*/
1488:../SSC/Src/objdef.c ****                         case    DEFTYPE_WORD:
1489:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO9*/
1490:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO1*/
1491:../SSC/Src/objdef.c ****                             if(bitOffset & 0xF)
 3102              	 .loc 1 1491 0
 3103 0408 3B8B     	 ldrh r3,[r7,#24]
 3104 040a 03F00F03 	 and r3,r3,#15
 3105 040e 002B     	 cmp r3,#0
 3106 0410 01D0     	 beq .L223
1492:../SSC/Src/objdef.c ****                             {
1493:../SSC/Src/objdef.c ****                                 /* return an error in case of an odd word offset (to support 16bit 
1494:../SSC/Src/objdef.c ****                                 return ABORTIDX_UNSUPPORTED_ACCESS;
 3107              	 .loc 1 1494 0
 3108 0412 0523     	 movs r3,#5
 3109 0414 12E1     	 b .L179
 3110              	.L223:
 3111              	.LBB24:
1495:../SSC/Src/objdef.c ****                             }
1496:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO1*/
1497:../SSC/Src/objdef.c **** 
1498:../SSC/Src/objdef.c ****                             {
1499:../SSC/Src/objdef.c ****                             /* in this example the objects are defined in that way,
1500:../SSC/Src/objdef.c ****                             that the 16 bit type are always starting at an exact WORD offset */
1501:../SSC/Src/objdef.c ****                             UINT16 u16NewData = SWAPWORD(pData[0]);
 3112              	 .loc 1 1501 0
 3113 0416 BB6C     	 ldr r3,[r7,#72]
 3114 0418 1B88     	 ldrh r3,[r3]
 3115 041a BB82     	 strh r3,[r7,#20]
1502:../SSC/Src/objdef.c ****                             if(bClearSubindex0Required && (pVarPtr[0] != u16NewData))
 3116              	 .loc 1 1502 0
 3117 041c 97F83330 	 ldrb r3,[r7,#51]
 3118 0420 002B     	 cmp r3,#0
 3119 0422 06D0     	 beq .L224
 3120              	 .loc 1 1502 0 is_stmt 0 discriminator 1
 3121 0424 BB6A     	 ldr r3,[r7,#40]
 3122 0426 1B88     	 ldrh r3,[r3]
 3123 0428 BA8A     	 ldrh r2,[r7,#20]
 3124 042a 9A42     	 cmp r2,r3
 3125 042c 01D0     	 beq .L224
1503:../SSC/Src/objdef.c ****                             {
1504:../SSC/Src/objdef.c ****                                 /* try to write new data when subindex0 shall be reset*/
1505:../SSC/Src/objdef.c ****                                 return ABORTIDX_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0;
 3126              	 .loc 1 1505 0 is_stmt 1
 3127 042e 1C23     	 movs r3,#28
 3128 0430 04E1     	 b .L179
 3129              	.L224:
1506:../SSC/Src/objdef.c ****                             }
1507:../SSC/Src/objdef.c **** 
1508:../SSC/Src/objdef.c ****                             /*check value if a new PDO assign entry should be written*/
1509:../SSC/Src/objdef.c ****                             if(IS_PDO_ASSIGN(index))  //PDO assign
 3130              	 .loc 1 1509 0
 3131 0432 FB89     	 ldrh r3,[r7,#14]
 3132 0434 41F60F42 	 movw r2,#7183
 3133 0438 9342     	 cmp r3,r2
 3134 043a 19D9     	 bls .L225
 3135              	 .loc 1 1509 0 is_stmt 0 discriminator 1
 3136 043c FB89     	 ldrh r3,[r7,#14]
 3137 043e 41F62F42 	 movw r2,#7215
 3138 0442 9342     	 cmp r3,r2
 3139 0444 14D8     	 bhi .L225
1510:../SSC/Src/objdef.c ****                             {
1511:../SSC/Src/objdef.c ****                                 if (!IS_RX_PDO(u16NewData) && !IS_TX_PDO(u16NewData) && (u16NewData
 3140              	 .loc 1 1511 0 is_stmt 1
 3141 0446 BB8A     	 ldrh r3,[r7,#20]
 3142 0448 B3F5B05F 	 cmp r3,#5632
 3143 044c 03D3     	 bcc .L226
 3144              	 .loc 1 1511 0 is_stmt 0 discriminator 2
 3145 044e BB8A     	 ldrh r3,[r7,#20]
 3146 0450 B3F5C05F 	 cmp r3,#6144
 3147 0454 0CD3     	 bcc .L225
 3148              	.L226:
 3149              	 .loc 1 1511 0 discriminator 3
 3150 0456 BB8A     	 ldrh r3,[r7,#20]
 3151 0458 B3F5D05F 	 cmp r3,#6656
 3152 045c 03D3     	 bcc .L227
 3153              	 .loc 1 1511 0 discriminator 5
 3154 045e BB8A     	 ldrh r3,[r7,#20]
 3155 0460 B3F5E05F 	 cmp r3,#7168
 3156 0464 04D3     	 bcc .L225
 3157              	.L227:
 3158              	 .loc 1 1511 0 discriminator 6
 3159 0466 BB8A     	 ldrh r3,[r7,#20]
 3160 0468 002B     	 cmp r3,#0
 3161 046a 01D0     	 beq .L225
1512:../SSC/Src/objdef.c ****                                 {
1513:../SSC/Src/objdef.c ****                                     return ABORTIDX_VALUE_EXCEEDED;
 3162              	 .loc 1 1513 0 is_stmt 1
 3163 046c 1223     	 movs r3,#18
 3164 046e E5E0     	 b .L179
 3165              	.L225:
1514:../SSC/Src/objdef.c ****                                 }
1515:../SSC/Src/objdef.c ****                             }
1516:../SSC/Src/objdef.c **** 
1517:../SSC/Src/objdef.c ****                             if((index == 0x1C32 || index == 0x1C33) && (i == 1))
 3166              	 .loc 1 1517 0
 3167 0470 FB89     	 ldrh r3,[r7,#14]
 3168 0472 41F63242 	 movw r2,#7218
 3169 0476 9342     	 cmp r3,r2
 3170 0478 04D0     	 beq .L228
 3171              	 .loc 1 1517 0 is_stmt 0 discriminator 2
 3172 047a FB89     	 ldrh r3,[r7,#14]
 3173 047c 41F63342 	 movw r2,#7219
 3174 0480 9342     	 cmp r3,r2
 3175 0482 1AD1     	 bne .L229
 3176              	.L228:
 3177              	 .loc 1 1517 0 discriminator 3
 3178 0484 FB8E     	 ldrh r3,[r7,#54]
 3179 0486 012B     	 cmp r3,#1
 3180 0488 17D1     	 bne .L229
1518:../SSC/Src/objdef.c ****                             {
1519:../SSC/Src/objdef.c ****                                 /* The Synchronisation type (0x1C3x.1) was written by the user => t
1520:../SSC/Src/objdef.c ****                                 if(pVarPtr[0] != u16NewData)
 3181              	 .loc 1 1520 0 is_stmt 1
 3182 048a BB6A     	 ldr r3,[r7,#40]
 3183 048c 1B88     	 ldrh r3,[r3]
 3184 048e BA8A     	 ldrh r2,[r7,#20]
 3185 0490 9A42     	 cmp r2,r3
 3186 0492 0FD0     	 beq .L230
1521:../SSC/Src/objdef.c ****                                 {
1522:../SSC/Src/objdef.c ****                                     result = CheckSyncTypeValue(index,u16NewData);
 3187              	 .loc 1 1522 0
 3188 0494 FA89     	 ldrh r2,[r7,#14]
 3189 0496 BB8A     	 ldrh r3,[r7,#20]
 3190 0498 1046     	 mov r0,r2
 3191 049a 1946     	 mov r1,r3
 3192 049c FFF7FEFF 	 bl CheckSyncTypeValue
 3193 04a0 0346     	 mov r3,r0
 3194 04a2 87F82E30 	 strb r3,[r7,#46]
1523:../SSC/Src/objdef.c **** 
1524:../SSC/Src/objdef.c ****                                     if(result != 0)
 3195              	 .loc 1 1524 0
 3196 04a6 97F82E30 	 ldrb r3,[r7,#46]
 3197 04aa 002B     	 cmp r3,#0
 3198 04ac 02D0     	 beq .L230
1525:../SSC/Src/objdef.c ****                                         return result;
 3199              	 .loc 1 1525 0
 3200 04ae 97F82E30 	 ldrb r3,[r7,#46]
 3201 04b2 C3E0     	 b .L179
 3202              	.L230:
1526:../SSC/Src/objdef.c ****                                 }
1527:../SSC/Src/objdef.c **** 
1528:../SSC/Src/objdef.c ****                                 /* The user may force to current Sync Mode for that reason the flag
1529:../SSC/Src/objdef.c ****                                 bSyncSetByUser = TRUE;
 3203              	 .loc 1 1529 0
 3204 04b4 4A4B     	 ldr r3,.L245+4
 3205 04b6 0122     	 movs r2,#1
 3206 04b8 1A70     	 strb r2,[r3]
 3207              	.L229:
1530:../SSC/Src/objdef.c ****                             }
1531:../SSC/Src/objdef.c **** 
1532:../SSC/Src/objdef.c ****                             pVarPtr[0] = u16NewData;
 3208              	 .loc 1 1532 0
 3209 04ba BB6A     	 ldr r3,[r7,#40]
 3210 04bc BA8A     	 ldrh r2,[r7,#20]
 3211 04be 1A80     	 strh r2,[r3]
1533:../SSC/Src/objdef.c ****                             pData++;
 3212              	 .loc 1 1533 0
 3213 04c0 BB6C     	 ldr r3,[r7,#72]
 3214 04c2 0233     	 adds r3,r3,#2
 3215 04c4 BB64     	 str r3,[r7,#72]
 3216              	.LBE24:
1534:../SSC/Src/objdef.c ****                             }
1535:../SSC/Src/objdef.c ****                             break;
 3217              	 .loc 1 1535 0
 3218 04c6 7DE0     	 b .L197
 3219              	.L209:
1536:../SSC/Src/objdef.c ****                         case    DEFTYPE_UNSIGNED32:
1537:../SSC/Src/objdef.c ****                         case    DEFTYPE_INTEGER32:
1538:../SSC/Src/objdef.c ****                         case    DEFTYPE_REAL32:
1539:../SSC/Src/objdef.c ****                         case    DEFTYPE_BITARR32:
1540:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO9*/
1541:../SSC/Src/objdef.c ****                         case    DEFTYPE_DWORD:
1542:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO9*/
1543:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO1*/
1544:../SSC/Src/objdef.c ****                             if(bitOffset & 0xF)
 3220              	 .loc 1 1544 0
 3221 04c8 3B8B     	 ldrh r3,[r7,#24]
 3222 04ca 03F00F03 	 and r3,r3,#15
 3223 04ce 002B     	 cmp r3,#0
 3224 04d0 01D0     	 beq .L231
1545:../SSC/Src/objdef.c ****                             {
1546:../SSC/Src/objdef.c ****                                 /* return an error in case of an odd word offset (to support 16bit 
1547:../SSC/Src/objdef.c ****                                 return ABORTIDX_UNSUPPORTED_ACCESS;
 3225              	 .loc 1 1547 0
 3226 04d2 0523     	 movs r3,#5
 3227 04d4 B2E0     	 b .L179
 3228              	.L231:
1548:../SSC/Src/objdef.c ****                             }
1549:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO1*/
1550:../SSC/Src/objdef.c ****                             {
1551:../SSC/Src/objdef.c **** 
1552:../SSC/Src/objdef.c ****                             /* in this example the objects are defined in that way,
1553:../SSC/Src/objdef.c ****                                that the 32 bit type are always starting at an exact WORD offset */
1554:../SSC/Src/objdef.c ****                             if(bClearSubindex0Required && 
 3229              	 .loc 1 1554 0
 3230 04d6 97F83330 	 ldrb r3,[r7,#51]
 3231 04da 002B     	 cmp r3,#0
 3232 04dc 0FD0     	 beq .L232
1555:../SSC/Src/objdef.c ****                                 ((pVarPtr[0] != pData[0])
 3233              	 .loc 1 1555 0 discriminator 1
 3234 04de BB6A     	 ldr r3,[r7,#40]
 3235 04e0 1A88     	 ldrh r2,[r3]
 3236 04e2 BB6C     	 ldr r3,[r7,#72]
 3237 04e4 1B88     	 ldrh r3,[r3]
1554:../SSC/Src/objdef.c ****                                 ((pVarPtr[0] != pData[0])
 3238              	 .loc 1 1554 0 discriminator 1
 3239 04e6 9A42     	 cmp r2,r3
 3240 04e8 07D1     	 bne .L233
1556:../SSC/Src/objdef.c ****                                 || (pVarPtr[1] != pData[1])))
 3241              	 .loc 1 1556 0
 3242 04ea BB6A     	 ldr r3,[r7,#40]
 3243 04ec 0233     	 adds r3,r3,#2
 3244 04ee 1A88     	 ldrh r2,[r3]
 3245 04f0 BB6C     	 ldr r3,[r7,#72]
 3246 04f2 0233     	 adds r3,r3,#2
 3247 04f4 1B88     	 ldrh r3,[r3]
 3248 04f6 9A42     	 cmp r2,r3
 3249 04f8 01D0     	 beq .L232
 3250              	.L233:
1557:../SSC/Src/objdef.c ****                             {
1558:../SSC/Src/objdef.c ****                                 /* try to write new data when subindex0 shall be reset*/
1559:../SSC/Src/objdef.c ****                                 return ABORTIDX_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0;
 3251              	 .loc 1 1559 0
 3252 04fa 1C23     	 movs r3,#28
 3253 04fc 9EE0     	 b .L179
 3254              	.L232:
1560:../SSC/Src/objdef.c ****                             }
1561:../SSC/Src/objdef.c **** 
1562:../SSC/Src/objdef.c ****                             pVarPtr[0] = pData[0];
 3255              	 .loc 1 1562 0
 3256 04fe BB6C     	 ldr r3,[r7,#72]
 3257 0500 1A88     	 ldrh r2,[r3]
 3258 0502 BB6A     	 ldr r3,[r7,#40]
 3259 0504 1A80     	 strh r2,[r3]
1563:../SSC/Src/objdef.c ****                             pVarPtr[1] = pData[1];
 3260              	 .loc 1 1563 0
 3261 0506 BB6A     	 ldr r3,[r7,#40]
 3262 0508 0233     	 adds r3,r3,#2
 3263 050a BA6C     	 ldr r2,[r7,#72]
 3264 050c 5288     	 ldrh r2,[r2,#2]
 3265 050e 1A80     	 strh r2,[r3]
1564:../SSC/Src/objdef.c ****                             pData += 2;
 3266              	 .loc 1 1564 0
 3267 0510 BB6C     	 ldr r3,[r7,#72]
 3268 0512 0433     	 adds r3,r3,#4
 3269 0514 BB64     	 str r3,[r7,#72]
1565:../SSC/Src/objdef.c ****                             }
1566:../SSC/Src/objdef.c ****                             break;
 3270              	 .loc 1 1566 0
 3271 0516 55E0     	 b .L197
 3272              	.L202:
1567:../SSC/Src/objdef.c ****                         case    DEFTYPE_REAL64:
1568:../SSC/Src/objdef.c ****                         case 	DEFTYPE_INTEGER64:
1569:../SSC/Src/objdef.c ****                         case    DEFTYPE_UNSIGNED64:
1570:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO1*/
1571:../SSC/Src/objdef.c ****                             if(bitOffset & 0xF)
 3273              	 .loc 1 1571 0
 3274 0518 3B8B     	 ldrh r3,[r7,#24]
 3275 051a 03F00F03 	 and r3,r3,#15
 3276 051e 002B     	 cmp r3,#0
 3277 0520 01D0     	 beq .L234
1572:../SSC/Src/objdef.c ****                             {
1573:../SSC/Src/objdef.c ****                                 /* return an error in case of an odd word offset (to support 16bit 
1574:../SSC/Src/objdef.c ****                                 return ABORTIDX_UNSUPPORTED_ACCESS;
 3278              	 .loc 1 1574 0
 3279 0522 0523     	 movs r3,#5
 3280 0524 8AE0     	 b .L179
 3281              	.L234:
1575:../SSC/Src/objdef.c ****                             }
1576:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO1*/
1577:../SSC/Src/objdef.c ****                             /* in this example the objects are defined in that way,
1578:../SSC/Src/objdef.c ****                                that the 64 bit type are always starting at an exact WORD offset */
1579:../SSC/Src/objdef.c ****                             pVarPtr[0] = pData[0];
 3282              	 .loc 1 1579 0
 3283 0526 BB6C     	 ldr r3,[r7,#72]
 3284 0528 1A88     	 ldrh r2,[r3]
 3285 052a BB6A     	 ldr r3,[r7,#40]
 3286 052c 1A80     	 strh r2,[r3]
1580:../SSC/Src/objdef.c ****                             pVarPtr[1] = pData[1];
 3287              	 .loc 1 1580 0
 3288 052e BB6A     	 ldr r3,[r7,#40]
 3289 0530 0233     	 adds r3,r3,#2
 3290 0532 BA6C     	 ldr r2,[r7,#72]
 3291 0534 5288     	 ldrh r2,[r2,#2]
 3292 0536 1A80     	 strh r2,[r3]
1581:../SSC/Src/objdef.c ****                             pVarPtr[2] = pData[2];
 3293              	 .loc 1 1581 0
 3294 0538 BB6A     	 ldr r3,[r7,#40]
 3295 053a 0433     	 adds r3,r3,#4
 3296 053c BA6C     	 ldr r2,[r7,#72]
 3297 053e 9288     	 ldrh r2,[r2,#4]
 3298 0540 1A80     	 strh r2,[r3]
1582:../SSC/Src/objdef.c ****                             pVarPtr[3] = pData[3];
 3299              	 .loc 1 1582 0
 3300 0542 BB6A     	 ldr r3,[r7,#40]
 3301 0544 0633     	 adds r3,r3,#6
 3302 0546 BA6C     	 ldr r2,[r7,#72]
 3303 0548 D288     	 ldrh r2,[r2,#6]
 3304 054a 1A80     	 strh r2,[r3]
1583:../SSC/Src/objdef.c ****                             pData += 4;
 3305              	 .loc 1 1583 0
 3306 054c BB6C     	 ldr r3,[r7,#72]
 3307 054e 0833     	 adds r3,r3,#8
 3308 0550 BB64     	 str r3,[r7,#72]
1584:../SSC/Src/objdef.c ****                             break;
 3309              	 .loc 1 1584 0
 3310 0552 37E0     	 b .L197
 3311              	.L211:
1585:../SSC/Src/objdef.c ****                         case    DEFTYPE_VISIBLESTRING:
1586:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO1*/
1587:../SSC/Src/objdef.c ****                             if(bitOffset & 0xF)
 3312              	 .loc 1 1587 0
 3313 0554 3B8B     	 ldrh r3,[r7,#24]
 3314 0556 03F00F03 	 and r3,r3,#15
 3315 055a 002B     	 cmp r3,#0
 3316 055c 01D0     	 beq .L235
1588:../SSC/Src/objdef.c ****                             {
1589:../SSC/Src/objdef.c ****                                 /* return an error in case of an odd word offset (to support 16bit 
1590:../SSC/Src/objdef.c ****                                 return ABORTIDX_UNSUPPORTED_ACCESS;
 3317              	 .loc 1 1590 0
 3318 055e 0523     	 movs r3,#5
 3319 0560 6CE0     	 b .L179
 3320              	.L235:
1591:../SSC/Src/objdef.c ****                             }
1592:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO1*/
1593:../SSC/Src/objdef.c **** 
1594:../SSC/Src/objdef.c ****                             OBJTOMBXSTRCPY(pVarPtr, pData, BIT2BYTE(pEntry->BitLength));
 3321              	 .loc 1 1594 0
 3322 0562 FB69     	 ldr r3,[r7,#28]
 3323 0564 5B88     	 ldrh r3,[r3,#2]
 3324 0566 0733     	 adds r3,r3,#7
 3325 0568 DB10     	 asrs r3,r3,#3
 3326 056a B86A     	 ldr r0,[r7,#40]
 3327 056c B96C     	 ldr r1,[r7,#72]
 3328 056e 1A46     	 mov r2,r3
 3329 0570 FFF7FEFF 	 bl memcpy
1595:../SSC/Src/objdef.c **** 
1596:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO2*/
1597:../SSC/Src/objdef.c ****                             pData += BIT2WORD((pEntry->BitLength)& ~0xF);
 3330              	 .loc 1 1597 0
 3331 0574 FB69     	 ldr r3,[r7,#28]
 3332 0576 5B88     	 ldrh r3,[r3,#2]
 3333 0578 23F00F03 	 bic r3,r3,#15
 3334 057c 0F33     	 adds r3,r3,#15
 3335 057e 1B11     	 asrs r3,r3,#4
 3336 0580 5B00     	 lsls r3,r3,#1
 3337 0582 BA6C     	 ldr r2,[r7,#72]
 3338 0584 1344     	 add r3,r3,r2
 3339 0586 BB64     	 str r3,[r7,#72]
1598:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO2*/
1599:../SSC/Src/objdef.c ****                             break;
 3340              	 .loc 1 1599 0
 3341 0588 1CE0     	 b .L197
 3342              	.L212:
1600:../SSC/Src/objdef.c ****                         case    DEFTYPE_OCTETSTRING:
1601:../SSC/Src/objdef.c ****                         case    DEFTYPE_UNICODE_STRING:
1602:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO9*/
1603:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_INT :
1604:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_SINT :
1605:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_DINT :
1606:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_UDINT:
1607:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO9*/
1608:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO1*/
1609:../SSC/Src/objdef.c ****                             if(bitOffset & 0xF)
 3343              	 .loc 1 1609 0
 3344 058a 3B8B     	 ldrh r3,[r7,#24]
 3345 058c 03F00F03 	 and r3,r3,#15
 3346 0590 002B     	 cmp r3,#0
 3347 0592 01D0     	 beq .L236
1610:../SSC/Src/objdef.c ****                             {
1611:../SSC/Src/objdef.c ****                                 /* return an error in case of an odd word offset (to support 16bit 
1612:../SSC/Src/objdef.c ****                                 return ABORTIDX_UNSUPPORTED_ACCESS;
 3348              	 .loc 1 1612 0
 3349 0594 0523     	 movs r3,#5
 3350 0596 51E0     	 b .L179
 3351              	.L236:
1613:../SSC/Src/objdef.c ****                             }
1614:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO1*/
1615:../SSC/Src/objdef.c **** 
1616:../SSC/Src/objdef.c ****                             /* in this example the objects are defined in that way,
1617:../SSC/Src/objdef.c ****                                that the other types are always starting at an even byte offset */
1618:../SSC/Src/objdef.c ****                             OBJTOMBXMEMCPY(pVarPtr, pData, BIT2BYTE(pEntry->BitLength));
 3352              	 .loc 1 1618 0
 3353 0598 FB69     	 ldr r3,[r7,#28]
 3354 059a 5B88     	 ldrh r3,[r3,#2]
 3355 059c 0733     	 adds r3,r3,#7
 3356 059e DB10     	 asrs r3,r3,#3
 3357 05a0 B86A     	 ldr r0,[r7,#40]
 3358 05a2 B96C     	 ldr r1,[r7,#72]
 3359 05a4 1A46     	 mov r2,r3
 3360 05a6 FFF7FEFF 	 bl memcpy
1619:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO2*/
1620:../SSC/Src/objdef.c ****                             pData += BIT2WORD((pEntry->BitLength) & ~0xF);
 3361              	 .loc 1 1620 0
 3362 05aa FB69     	 ldr r3,[r7,#28]
 3363 05ac 5B88     	 ldrh r3,[r3,#2]
 3364 05ae 23F00F03 	 bic r3,r3,#15
 3365 05b2 0F33     	 adds r3,r3,#15
 3366 05b4 1B11     	 asrs r3,r3,#4
 3367 05b6 5B00     	 lsls r3,r3,#1
 3368 05b8 BA6C     	 ldr r2,[r7,#72]
 3369 05ba 1344     	 add r3,r3,r2
 3370 05bc BB64     	 str r3,[r7,#72]
1621:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO2*/
1622:../SSC/Src/objdef.c **** 
1623:../SSC/Src/objdef.c ****                             break;
 3371              	 .loc 1 1623 0
 3372 05be 01E0     	 b .L197
 3373              	.L201:
1624:../SSC/Src/objdef.c ****                         default:
1625:../SSC/Src/objdef.c ****                             /* other data types are not supported from this example */
1626:../SSC/Src/objdef.c ****                             return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
 3374              	 .loc 1 1626 0
 3375 05c0 1823     	 movs r3,#24
 3376 05c2 3BE0     	 b .L179
 3377              	.L197:
 3378              	.LBE22:
1627:../SSC/Src/objdef.c ****                         }
1628:../SSC/Src/objdef.c ****                     }
1629:../SSC/Src/objdef.c **** 
1630:../SSC/Src/objdef.c ****                     /* set flag */
1631:../SSC/Src/objdef.c ****                     bWritten = 1;
 3379              	 .loc 1 1631 0
 3380 05c4 0123     	 movs r3,#1
 3381 05c6 87F82F30 	 strb r3,[r7,#47]
 3382 05ca 27E0     	 b .L237
 3383              	.L191:
 3384              	.LBE20:
1632:../SSC/Src/objdef.c **** 
1633:../SSC/Src/objdef.c ****                 }
1634:../SSC/Src/objdef.c ****             }
1635:../SSC/Src/objdef.c ****             else
1636:../SSC/Src/objdef.c ****             {
1637:../SSC/Src/objdef.c ****                 if(i == 0)
 3385              	 .loc 1 1637 0
 3386 05cc FB8E     	 ldrh r3,[r7,#54]
 3387 05ce 002B     	 cmp r3,#0
 3388 05d0 08D1     	 bne .L238
1638:../SSC/Src/objdef.c ****                 {
1639:../SSC/Src/objdef.c ****                     /* For SubIndex0 16Bit are reserved even if the BitLength is 8 */
1640:../SSC/Src/objdef.c ****                     pData++;
 3389              	 .loc 1 1640 0
 3390 05d2 BB6C     	 ldr r3,[r7,#72]
 3391 05d4 0233     	 adds r3,r3,#2
 3392 05d6 BB64     	 str r3,[r7,#72]
 3393 05d8 1DE0     	 b .L239
 3394              	.L246:
 3395 05da 00BF     	 .align 2
 3396              	.L245:
 3397 05dc 00000000 	 .word cBitMask
 3398 05e0 00000000 	 .word bSyncSetByUser
 3399              	.L238:
1641:../SSC/Src/objdef.c ****                 }
1642:../SSC/Src/objdef.c ****                 else
1643:../SSC/Src/objdef.c ****                 {
1644:../SSC/Src/objdef.c ****                     /*Handle Bit/Byte Offset*/
1645:../SSC/Src/objdef.c ****                     if (((pEntry->BitLength & 0xF) > 0)
 3400              	 .loc 1 1645 0
 3401 05e4 FB69     	 ldr r3,[r7,#28]
 3402 05e6 5B88     	 ldrh r3,[r3,#2]
 3403 05e8 03F00F03 	 and r3,r3,#15
 3404 05ec 002B     	 cmp r3,#0
 3405 05ee 0ADD     	 ble .L240
1646:../SSC/Src/objdef.c ****                         && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
 3406              	 .loc 1 1646 0
 3407 05f0 3B8B     	 ldrh r3,[r7,#24]
 3408 05f2 FA69     	 ldr r2,[r7,#28]
 3409 05f4 5288     	 ldrh r2,[r2,#2]
 3410 05f6 1344     	 add r3,r3,r2
 3411 05f8 03F00F03 	 and r3,r3,#15
 3412 05fc 002B     	 cmp r3,#0
 3413 05fe 02D1     	 bne .L240
1647:../SSC/Src/objdef.c ****                     {
1648:../SSC/Src/objdef.c ****                         /* we have reached the UINT16 border */
1649:../SSC/Src/objdef.c ****                         pData++;
 3414              	 .loc 1 1649 0
 3415 0600 BB6C     	 ldr r3,[r7,#72]
 3416 0602 0233     	 adds r3,r3,#2
 3417 0604 BB64     	 str r3,[r7,#72]
 3418              	.L240:
1650:../SSC/Src/objdef.c ****                     }
1651:../SSC/Src/objdef.c **** 
1652:../SSC/Src/objdef.c ****                     /*increment WORD offset*/
1653:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.11) SDO9*/
1654:../SSC/Src/objdef.c ****                     pData += ((pEntry->BitLength & 0xFFF0) >> 4);
 3419              	 .loc 1 1654 0
 3420 0606 FB69     	 ldr r3,[r7,#28]
 3421 0608 5B88     	 ldrh r3,[r3,#2]
 3422 060a 1B09     	 lsrs r3,r3,#4
 3423 060c 9BB2     	 uxth r3,r3
 3424 060e 5B00     	 lsls r3,r3,#1
 3425 0610 BA6C     	 ldr r2,[r7,#72]
 3426 0612 1344     	 add r3,r3,r2
 3427 0614 BB64     	 str r3,[r7,#72]
 3428              	.L239:
1655:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.11) SDO9*/
1656:../SSC/Src/objdef.c ****                 }
1657:../SSC/Src/objdef.c ****                 /*If no other entry was written this result will be returned*/
1658:../SSC/Src/objdef.c ****                 result = ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
 3429              	 .loc 1 1658 0
 3430 0616 1823     	 movs r3,#24
 3431 0618 87F82E30 	 strb r3,[r7,#46]
 3432              	.L237:
 3433              	.LBE19:
1342:../SSC/Src/objdef.c ****         {
 3434              	 .loc 1 1342 0 discriminator 2
 3435 061c FB8E     	 ldrh r3,[r7,#54]
 3436 061e 0133     	 adds r3,r3,#1
 3437 0620 FB86     	 strh r3,[r7,#54]
 3438              	.L190:
1342:../SSC/Src/objdef.c ****         {
 3439              	 .loc 1 1342 0 is_stmt 0 discriminator 1
 3440 0622 FA8E     	 ldrh r2,[r7,#54]
 3441 0624 3B8E     	 ldrh r3,[r7,#48]
 3442 0626 9A42     	 cmp r2,r3
 3443 0628 7FF6B2AD 	 bls .L241
1659:../SSC/Src/objdef.c ****             }
1660:../SSC/Src/objdef.c ****         }
1661:../SSC/Src/objdef.c **** 
1662:../SSC/Src/objdef.c ****         if (bWritten == 0)
 3444              	 .loc 1 1662 0 is_stmt 1
 3445 062c 97F82F30 	 ldrb r3,[r7,#47]
 3446 0630 002B     	 cmp r3,#0
 3447 0632 02D1     	 bne .L242
1663:../SSC/Src/objdef.c ****             /* we didn't write anything, so we have to return the stored error code */
1664:../SSC/Src/objdef.c ****             return result;
 3448              	 .loc 1 1664 0
 3449 0634 97F82E30 	 ldrb r3,[r7,#46]
 3450 0638 00E0     	 b .L179
 3451              	.L242:
 3452              	.LBE18:
1665:../SSC/Src/objdef.c ****     }
1666:../SSC/Src/objdef.c **** 
1667:../SSC/Src/objdef.c ****     return 0;
 3453              	 .loc 1 1667 0
 3454 063a 0023     	 movs r3,#0
 3455              	.L179:
1668:../SSC/Src/objdef.c **** }
 3456              	 .loc 1 1668 0
 3457 063c 1846     	 mov r0,r3
 3458 063e 3C37     	 adds r7,r7,#60
 3459              	.LCFI64:
 3460              	 .cfi_def_cfa_offset 12
 3461 0640 BD46     	 mov sp,r7
 3462              	.LCFI65:
 3463              	 .cfi_def_cfa_register 13
 3464              	 
 3465 0642 90BD     	 pop {r4,r7,pc}
 3466              	 .cfi_endproc
 3467              	.LFE183:
 3469              	 .text
 3470              	.Letext0:
 3471              	 .file 2 "c:\\davev4-64bit\\dave-4.3.2\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 3472              	 .file 3 "c:\\davev4-64bit\\dave-4.3.2\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 3473              	 .file 4 "../SSC/Src/sdoserv.h"
 3474              	 .file 5 "../SSC/Src/objdef.h"
 3475              	 .file 6 "E:/xmc_1124/XMC4300_Relax_EtherCat_APP_Slave_SSC/Libraries/CMSIS/Include/core_cm4.h"
 3476              	 .file 7 "../SSC/Src/ecatslv.h"
DEFINED SYMBOLS
                            *ABS*:00000000 objdef.c
                            *COM*:00000001 bSyncSetByUser
                            *COM*:00000002 sCycleDiag
                            *COM*:00000044 sSyncManOutPar
                            *COM*:00000044 sSyncManInPar
    {standard input}:28     .data.sErrorSettings:00000000 sErrorSettings
    {standard input}:25     .data.sErrorSettings:00000000 $d
    {standard input}:39     .data.aSubindexDesc:00000000 aSubindexDesc
    {standard input}:36     .data.aSubindexDesc:00000000 $d
    {standard input}:46     .rodata.cBitMask:00000000 cBitMask
    {standard input}:43     .rodata.cBitMask:00000000 $d
    {standard input}:64     .text.OBJ_GetObjectHandle:00000000 $t
    {standard input}:69     .text.OBJ_GetObjectHandle:00000000 OBJ_GetObjectHandle
    {standard input}:131    .text.OBJ_GetObjectLength:00000000 $t
    {standard input}:136    .text.OBJ_GetObjectLength:00000000 OBJ_GetObjectLength
    {standard input}:335    .text.OBJ_CopyNumberToString:00000000 $t
    {standard input}:340    .text.OBJ_CopyNumberToString:00000000 OBJ_CopyNumberToString
    {standard input}:437    .text.OBJ_CopyNumberToString:0000008c $d
    {standard input}:443    .text.OBJ_GetNoOfObjects:00000000 $t
    {standard input}:448    .text.OBJ_GetNoOfObjects:00000000 OBJ_GetNoOfObjects
    {standard input}:986    .text.OBJ_GetEntryDesc:00000000 OBJ_GetEntryDesc
    {standard input}:574    .text.OBJ_GetObjectList:00000000 $t
    {standard input}:579    .text.OBJ_GetObjectList:00000000 OBJ_GetObjectList
    {standard input}:765    .text.OBJ_GetObjectList:000000f4 $d
    {standard input}:770    .text.OBJ_GetDesc:00000000 $t
    {standard input}:775    .text.OBJ_GetDesc:00000000 OBJ_GetDesc
    {standard input}:976    .text.OBJ_GetDesc:00000120 $d
    {standard input}:981    .text.OBJ_GetEntryDesc:00000000 $t
    {standard input}:1064   .text.OBJ_GetObjDesc:00000000 $t
    {standard input}:1069   .text.OBJ_GetObjDesc:00000000 OBJ_GetObjDesc
    {standard input}:1108   .text.OBJ_GetEntryOffset:00000000 $t
    {standard input}:1113   .text.OBJ_GetEntryOffset:00000000 OBJ_GetEntryOffset
    {standard input}:1359   .text.CheckSyncTypeValue:00000000 $t
    {standard input}:1364   .text.CheckSyncTypeValue:00000000 CheckSyncTypeValue
    {standard input}:1394   .text.CheckSyncTypeValue:00000020 $d
    {standard input}:1429   .text.CheckSyncTypeValue:000000ac $t
    {standard input}:1592   .text.CheckSyncTypeValue:0000019c $d
    {standard input}:1600   .text.OBJ_Read:00000000 $t
    {standard input}:1605   .text.OBJ_Read:00000000 OBJ_Read
    {standard input}:2075   .text.OBJ_Read:0000031c $d
    {standard input}:2079   .text.OBJ_Read:00000320 $t
    {standard input}:2478   .text.OBJ_Read:000005a4 $d
    {standard input}:2483   .text.OBJ_Write:00000000 $t
    {standard input}:2488   .text.OBJ_Write:00000000 OBJ_Write
    {standard input}:2999   .text.OBJ_Write:00000350 $d
    {standard input}:3003   .text.OBJ_Write:00000354 $t
    {standard input}:3397   .text.OBJ_Write:000005dc $d
    {standard input}:3401   .text.OBJ_Write:000005e4 $t
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
COE_GetObjectDictionary
pSdoInfoObjEntry
strlen
memcpy
nPdOutputSize
nPdInputSize
nAlStatus
